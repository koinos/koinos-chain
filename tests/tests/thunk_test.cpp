#include <algorithm>
#include <cmath>
#include <filesystem>
#include <fstream>
#include <numeric>
#include <random>
#include <type_traits>
#include <vector>

#include <boost/test/unit_test.hpp>
#include <boost/filesystem.hpp>

#include <google/protobuf/util/json_util.h>
#include <google/protobuf/util/message_differencer.h>

#include <koinos/log.hpp>

#include <koinos/chain/controller.hpp>
#include <koinos/chain/execution_context.hpp>
#include <koinos/chain/constants.hpp>
#include <koinos/chain/exceptions.hpp>
#include <koinos/chain/host_api.hpp>
#include <koinos/chain/thunk_dispatcher.hpp>
#include <koinos/chain/session.hpp>
#include <koinos/chain/state.hpp>
#include <koinos/chain/system_calls.hpp>

#include <koinos/crypto/elliptic.hpp>

#include <koinos/vm_manager/exceptions.hpp>

#include <koinos/contracts/token/token.pb.h>

#include <koinos/tests/contracts.hpp>

#include <koinos/util/base58.hpp>
#include <koinos/util/hex.hpp>

using namespace koinos;
using namespace std::string_literals;

struct thunk_fixture
{
   thunk_fixture() :
      vm_backend( koinos::vm_manager::get_vm_backend() ),
      ctx( vm_backend, chain::intent::block_application ),
      host( ctx )
   {
      KOINOS_ASSERT( vm_backend, koinos::chain::unknown_backend_exception, "could not get vm backend" );

      initialize_logging( "koinos_test", {}, "info" );

      temp = std::filesystem::temp_directory_path() / boost::filesystem::unique_path().string();
      std::filesystem::create_directory( temp );

      auto seed = "test seed"s;
      _signing_private_key = crypto::private_key::regenerate( crypto::hash( crypto::multicodec::sha2_256, seed ) );

      auto entry = _genesis_data.add_entries();
      entry->set_key( chain::state::key::genesis_key );
      entry->set_value( _signing_private_key.get_public_key().to_address_bytes() );
      *entry->mutable_space() = chain::state::space::metadata();

      koinos::chain::resource_limit_data rd;

      rd.set_disk_storage_cost( 10 );
      rd.set_disk_storage_limit( 500'800 );

      rd.set_network_bandwidth_cost( 5 );
      rd.set_network_bandwidth_limit( 1'048'576 );

      rd.set_compute_bandwidth_cost( 1 );
      rd.set_compute_bandwidth_limit( 100'000'000 );

      entry = _genesis_data.add_entries();
      entry->set_key( chain::state::key::resource_limit_data );
      entry->set_value( util::converter::as< std::string >( rd ) );
      *entry->mutable_space() = chain::state::space::metadata();

      koinos::chain::max_account_resources mar;

      mar.set_value( 10'000'000 );

      entry = _genesis_data.add_entries();
      entry->set_key( chain::state::key::max_account_resources );
      entry->set_value( util::converter::as< std::string >( mar ) );
      *entry->mutable_space() = chain::state::space::metadata();

      entry = _genesis_data.add_entries();
      entry->set_key( chain::state::key::protocol_descriptor );

      // protoc --experimental_allow_proto3_optional --descriptor_set_out=build/koinos_protocol.pb --include_imports `find koinos -name 'protocol.proto'`
      std::string protocol_descriptor = util::from_hex< std::string >( "0x0ac33b0a20676f6f676c652f70726f746f6275662f64657363726970746f722e70726f746f120f676f6f676c652e70726f746f627566224d0a1146696c6544657363726970746f7253657412380a0466696c6518012003280b32242e676f6f676c652e70726f746f6275662e46696c6544657363726970746f7250726f746f520466696c6522e4040a1346696c6544657363726970746f7250726f746f12120a046e616d6518012001280952046e616d6512180a077061636b61676518022001280952077061636b616765121e0a0a646570656e64656e6379180320032809520a646570656e64656e6379122b0a117075626c69635f646570656e64656e6379180a2003280552107075626c6963446570656e64656e637912270a0f7765616b5f646570656e64656e6379180b20032805520e7765616b446570656e64656e637912430a0c6d6573736167655f7479706518042003280b32202e676f6f676c652e70726f746f6275662e44657363726970746f7250726f746f520b6d6573736167655479706512410a09656e756d5f7479706518052003280b32242e676f6f676c652e70726f746f6275662e456e756d44657363726970746f7250726f746f5208656e756d5479706512410a077365727669636518062003280b32272e676f6f676c652e70726f746f6275662e5365727669636544657363726970746f7250726f746f52077365727669636512430a09657874656e73696f6e18072003280b32252e676f6f676c652e70726f746f6275662e4669656c6444657363726970746f7250726f746f5209657874656e73696f6e12360a076f7074696f6e7318082001280b321c2e676f6f676c652e70726f746f6275662e46696c654f7074696f6e7352076f7074696f6e7312490a10736f757263655f636f64655f696e666f18092001280b321f2e676f6f676c652e70726f746f6275662e536f75726365436f6465496e666f520e736f75726365436f6465496e666f12160a0673796e746178180c20012809520673796e74617822b9060a0f44657363726970746f7250726f746f12120a046e616d6518012001280952046e616d65123b0a056669656c6418022003280b32252e676f6f676c652e70726f746f6275662e4669656c6444657363726970746f7250726f746f52056669656c6412430a09657874656e73696f6e18062003280b32252e676f6f676c652e70726f746f6275662e4669656c6444657363726970746f7250726f746f5209657874656e73696f6e12410a0b6e65737465645f7479706518032003280b32202e676f6f676c652e70726f746f6275662e44657363726970746f7250726f746f520a6e65737465645479706512410a09656e756d5f7479706518042003280b32242e676f6f676c652e70726f746f6275662e456e756d44657363726970746f7250726f746f5208656e756d5479706512580a0f657874656e73696f6e5f72616e676518052003280b322f2e676f6f676c652e70726f746f6275662e44657363726970746f7250726f746f2e457874656e73696f6e52616e6765520e657874656e73696f6e52616e676512440a0a6f6e656f665f6465636c18082003280b32252e676f6f676c652e70726f746f6275662e4f6e656f6644657363726970746f7250726f746f52096f6e656f664465636c12390a076f7074696f6e7318072001280b321f2e676f6f676c652e70726f746f6275662e4d6573736167654f7074696f6e7352076f7074696f6e7312550a0e72657365727665645f72616e676518092003280b322e2e676f6f676c652e70726f746f6275662e44657363726970746f7250726f746f2e526573657276656452616e6765520d726573657276656452616e676512230a0d72657365727665645f6e616d65180a20032809520c72657365727665644e616d651a7a0a0e457874656e73696f6e52616e676512140a0573746172741801200128055205737461727412100a03656e641802200128055203656e6412400a076f7074696f6e7318032001280b32262e676f6f676c652e70726f746f6275662e457874656e73696f6e52616e67654f7074696f6e7352076f7074696f6e731a370a0d526573657276656452616e676512140a0573746172741801200128055205737461727412100a03656e641802200128055203656e64227c0a15457874656e73696f6e52616e67654f7074696f6e7312580a14756e696e7465727072657465645f6f7074696f6e18e7072003280b32242e676f6f676c652e70726f746f6275662e556e696e7465727072657465644f7074696f6e5213756e696e7465727072657465644f7074696f6e2a0908e80710808080800222c1060a144669656c6444657363726970746f7250726f746f12120a046e616d6518012001280952046e616d6512160a066e756d62657218032001280552066e756d62657212410a056c6162656c18042001280e322b2e676f6f676c652e70726f746f6275662e4669656c6444657363726970746f7250726f746f2e4c6162656c52056c6162656c123e0a047479706518052001280e322a2e676f6f676c652e70726f746f6275662e4669656c6444657363726970746f7250726f746f2e54797065520474797065121b0a09747970655f6e616d651806200128095208747970654e616d65121a0a08657874656e6465651802200128095208657874656e64656512230a0d64656661756c745f76616c7565180720012809520c64656661756c7456616c7565121f0a0b6f6e656f665f696e646578180920012805520a6f6e656f66496e646578121b0a096a736f6e5f6e616d65180a2001280952086a736f6e4e616d6512370a076f7074696f6e7318082001280b321d2e676f6f676c652e70726f746f6275662e4669656c644f7074696f6e7352076f7074696f6e7312270a0f70726f746f335f6f7074696f6e616c181120012808520e70726f746f334f7074696f6e616c22b6020a0454797065120f0a0b545950455f444f55424c451001120e0a0a545950455f464c4f41541002120e0a0a545950455f494e5436341003120f0a0b545950455f55494e5436341004120e0a0a545950455f494e543332100512100a0c545950455f46495845443634100612100a0c545950455f464958454433321007120d0a09545950455f424f4f4c1008120f0a0b545950455f535452494e471009120e0a0a545950455f47524f5550100a12100a0c545950455f4d455353414745100b120e0a0a545950455f4259544553100c120f0a0b545950455f55494e543332100d120d0a09545950455f454e554d100e12110a0d545950455f5346495845443332100f12110a0d545950455f53464958454436341010120f0a0b545950455f53494e5433321011120f0a0b545950455f53494e543634101222430a054c6162656c12120a0e4c4142454c5f4f5054494f4e414c100112120a0e4c4142454c5f5245515549524544100212120a0e4c4142454c5f5245504541544544100322630a144f6e656f6644657363726970746f7250726f746f12120a046e616d6518012001280952046e616d6512370a076f7074696f6e7318022001280b321d2e676f6f676c652e70726f746f6275662e4f6e656f664f7074696f6e7352076f7074696f6e7322e3020a13456e756d44657363726970746f7250726f746f12120a046e616d6518012001280952046e616d65123f0a0576616c756518022003280b32292e676f6f676c652e70726f746f6275662e456e756d56616c756544657363726970746f7250726f746f520576616c756512360a076f7074696f6e7318032001280b321c2e676f6f676c652e70726f746f6275662e456e756d4f7074696f6e7352076f7074696f6e73125d0a0e72657365727665645f72616e676518042003280b32362e676f6f676c652e70726f746f6275662e456e756d44657363726970746f7250726f746f2e456e756d526573657276656452616e6765520d726573657276656452616e676512230a0d72657365727665645f6e616d65180520032809520c72657365727665644e616d651a3b0a11456e756d526573657276656452616e676512140a0573746172741801200128055205737461727412100a03656e641802200128055203656e642283010a18456e756d56616c756544657363726970746f7250726f746f12120a046e616d6518012001280952046e616d6512160a066e756d62657218022001280552066e756d626572123b0a076f7074696f6e7318032001280b32212e676f6f676c652e70726f746f6275662e456e756d56616c75654f7074696f6e7352076f7074696f6e7322a7010a165365727669636544657363726970746f7250726f746f12120a046e616d6518012001280952046e616d65123e0a066d6574686f6418022003280b32262e676f6f676c652e70726f746f6275662e4d6574686f6444657363726970746f7250726f746f52066d6574686f6412390a076f7074696f6e7318032001280b321f2e676f6f676c652e70726f746f6275662e536572766963654f7074696f6e7352076f7074696f6e732289020a154d6574686f6444657363726970746f7250726f746f12120a046e616d6518012001280952046e616d65121d0a0a696e7075745f747970651802200128095209696e70757454797065121f0a0b6f75747075745f74797065180320012809520a6f75747075745479706512380a076f7074696f6e7318042001280b321e2e676f6f676c652e70726f746f6275662e4d6574686f644f7074696f6e7352076f7074696f6e7312300a10636c69656e745f73747265616d696e671805200128083a0566616c7365520f636c69656e7453747265616d696e6712300a107365727665725f73747265616d696e671806200128083a0566616c7365520f73657276657253747265616d696e672291090a0b46696c654f7074696f6e7312210a0c6a6176615f7061636b616765180120012809520b6a6176615061636b61676512300a146a6176615f6f757465725f636c6173736e616d6518082001280952126a6176614f75746572436c6173736e616d6512350a136a6176615f6d756c7469706c655f66696c6573180a200128083a0566616c736552116a6176614d756c7469706c6546696c657312440a1d6a6176615f67656e65726174655f657175616c735f616e645f686173681814200128084202180152196a61766147656e6572617465457175616c73416e6448617368123a0a166a6176615f737472696e675f636865636b5f75746638181b200128083a0566616c736552136a617661537472696e67436865636b5574663812530a0c6f7074696d697a655f666f7218092001280e32292e676f6f676c652e70726f746f6275662e46696c654f7074696f6e732e4f7074696d697a654d6f64653a055350454544520b6f7074696d697a65466f72121d0a0a676f5f7061636b616765180b200128095209676f5061636b61676512350a1363635f67656e657269635f73657276696365731810200128083a0566616c73655211636347656e65726963536572766963657312390a156a6176615f67656e657269635f73657276696365731811200128083a0566616c736552136a61766147656e65726963536572766963657312350a1370795f67656e657269635f73657276696365731812200128083a0566616c73655211707947656e65726963536572766963657312370a147068705f67656e657269635f7365727669636573182a200128083a0566616c7365521270687047656e65726963536572766963657312250a0a646570726563617465641817200128083a0566616c7365520a64657072656361746564122e0a1063635f656e61626c655f6172656e6173181f200128083a0474727565520e6363456e61626c654172656e6173122a0a116f626a635f636c6173735f707265666978182420012809520f6f626a63436c61737350726566697812290a106373686172705f6e616d657370616365182520012809520f6373686172704e616d65737061636512210a0c73776966745f707265666978182720012809520b737769667450726566697812280a107068705f636c6173735f707265666978182820012809520e706870436c61737350726566697812230a0d7068705f6e616d657370616365182920012809520c7068704e616d65737061636512340a167068705f6d657461646174615f6e616d657370616365182c2001280952147068704d657461646174614e616d65737061636512210a0c727562795f7061636b616765182d20012809520b727562795061636b61676512580a14756e696e7465727072657465645f6f7074696f6e18e7072003280b32242e676f6f676c652e70726f746f6275662e556e696e7465727072657465644f7074696f6e5213756e696e7465727072657465644f7074696f6e223a0a0c4f7074696d697a654d6f646512090a0553504545441001120d0a09434f44455f53495a45100212100a0c4c4954455f52554e54494d4510032a0908e8071080808080024a040826102722e3020a0e4d6573736167654f7074696f6e73123c0a176d6573736167655f7365745f776972655f666f726d61741801200128083a0566616c736552146d65737361676553657457697265466f726d6174124c0a1f6e6f5f7374616e646172645f64657363726970746f725f6163636573736f721802200128083a0566616c7365521c6e6f5374616e6461726444657363726970746f724163636573736f7212250a0a646570726563617465641803200128083a0566616c7365520a64657072656361746564121b0a096d61705f656e74727918072001280852086d6170456e74727912580a14756e696e7465727072657465645f6f7074696f6e18e7072003280b32242e676f6f676c652e70726f746f6275662e556e696e7465727072657465644f7074696f6e5213756e696e7465727072657465644f7074696f6e2a0908e8071080808080024a04080410054a04080510064a04080610074a04080810094a040809100a22e2030a0c4669656c644f7074696f6e7312410a05637479706518012001280e32232e676f6f676c652e70726f746f6275662e4669656c644f7074696f6e732e43547970653a06535452494e475205637479706512160a067061636b656418022001280852067061636b656412470a066a737479706518062001280e32242e676f6f676c652e70726f746f6275662e4669656c644f7074696f6e732e4a53547970653a094a535f4e4f524d414c52066a737479706512190a046c617a791805200128083a0566616c736552046c617a7912250a0a646570726563617465641803200128083a0566616c7365520a6465707265636174656412190a047765616b180a200128083a0566616c736552047765616b12580a14756e696e7465727072657465645f6f7074696f6e18e7072003280b32242e676f6f676c652e70726f746f6275662e556e696e7465727072657465644f7074696f6e5213756e696e7465727072657465644f7074696f6e222f0a054354797065120a0a06535452494e47100012080a04434f5244100112100a0c535452494e475f5049454345100222350a064a5354797065120d0a094a535f4e4f524d414c1000120d0a094a535f535452494e471001120d0a094a535f4e554d42455210022a0908e8071080808080024a040804100522730a0c4f6e656f664f7074696f6e7312580a14756e696e7465727072657465645f6f7074696f6e18e7072003280b32242e676f6f676c652e70726f746f6275662e556e696e7465727072657465644f7074696f6e5213756e696e7465727072657465644f7074696f6e2a0908e80710808080800222c0010a0b456e756d4f7074696f6e73121f0a0b616c6c6f775f616c696173180220012808520a616c6c6f77416c69617312250a0a646570726563617465641803200128083a0566616c7365520a6465707265636174656412580a14756e696e7465727072657465645f6f7074696f6e18e7072003280b32242e676f6f676c652e70726f746f6275662e556e696e7465727072657465644f7074696f6e5213756e696e7465727072657465644f7074696f6e2a0908e8071080808080024a0408051006229e010a10456e756d56616c75654f7074696f6e7312250a0a646570726563617465641801200128083a0566616c7365520a6465707265636174656412580a14756e696e7465727072657465645f6f7074696f6e18e7072003280b32242e676f6f676c652e70726f746f6275662e556e696e7465727072657465644f7074696f6e5213756e696e7465727072657465644f7074696f6e2a0908e807108080808002229c010a0e536572766963654f7074696f6e7312250a0a646570726563617465641821200128083a0566616c7365520a6465707265636174656412580a14756e696e7465727072657465645f6f7074696f6e18e7072003280b32242e676f6f676c652e70726f746f6275662e556e696e7465727072657465644f7074696f6e5213756e696e7465727072657465644f7074696f6e2a0908e80710808080800222e0020a0d4d6574686f644f7074696f6e7312250a0a646570726563617465641821200128083a0566616c7365520a6465707265636174656412710a116964656d706f74656e63795f6c6576656c18222001280e322f2e676f6f676c652e70726f746f6275662e4d6574686f644f7074696f6e732e4964656d706f74656e63794c6576656c3a134944454d504f54454e43595f554e4b4e4f574e52106964656d706f74656e63794c6576656c12580a14756e696e7465727072657465645f6f7074696f6e18e7072003280b32242e676f6f676c652e70726f746f6275662e556e696e7465727072657465644f7074696f6e5213756e696e7465727072657465644f7074696f6e22500a104964656d706f74656e63794c6576656c12170a134944454d504f54454e43595f554e4b4e4f574e100012130a0f4e4f5f534944455f454646454354531001120e0a0a4944454d504f54454e5410022a0908e807108080808002229a030a13556e696e7465727072657465644f7074696f6e12410a046e616d6518022003280b322d2e676f6f676c652e70726f746f6275662e556e696e7465727072657465644f7074696f6e2e4e616d655061727452046e616d6512290a106964656e7469666965725f76616c7565180320012809520f6964656e74696669657256616c7565122c0a12706f7369746976655f696e745f76616c75651804200128045210706f736974697665496e7456616c7565122c0a126e656761746976655f696e745f76616c756518052001280352106e65676174697665496e7456616c756512210a0c646f75626c655f76616c7565180620012801520b646f75626c6556616c756512210a0c737472696e675f76616c756518072001280c520b737472696e6756616c756512270a0f6167677265676174655f76616c7565180820012809520e61676772656761746556616c75651a4a0a084e616d6550617274121b0a096e616d655f7061727418012002280952086e616d655061727412210a0c69735f657874656e73696f6e180220022808520b6973457874656e73696f6e22a7020a0e536f75726365436f6465496e666f12440a086c6f636174696f6e18012003280b32282e676f6f676c652e70726f746f6275662e536f75726365436f6465496e666f2e4c6f636174696f6e52086c6f636174696f6e1ace010a084c6f636174696f6e12160a04706174681801200328054202100152047061746812160a047370616e1802200328054202100152047370616e12290a106c656164696e675f636f6d6d656e7473180320012809520f6c656164696e67436f6d6d656e7473122b0a11747261696c696e675f636f6d6d656e74731804200128095210747261696c696e67436f6d6d656e7473123a0a196c656164696e675f64657461636865645f636f6d6d656e747318062003280952176c656164696e674465746163686564436f6d6d656e747322d1010a1147656e657261746564436f6465496e666f124d0a0a616e6e6f746174696f6e18012003280b322d2e676f6f676c652e70726f746f6275662e47656e657261746564436f6465496e666f2e416e6e6f746174696f6e520a616e6e6f746174696f6e1a6d0a0a416e6e6f746174696f6e12160a047061746818012003280542021001520470617468121f0a0b736f757263655f66696c65180220012809520a736f7572636546696c6512140a05626567696e1803200128055205626567696e12100a03656e641804200128055203656e64427e0a13636f6d2e676f6f676c652e70726f746f627566421044657363726970746f7250726f746f7348015a2d676f6f676c652e676f6c616e672e6f72672f70726f746f6275662f74797065732f64657363726970746f727062f80101a20203475042aa021a476f6f676c652e50726f746f6275662e5265666c656374696f6e0ab5020a146b6f696e6f732f6f7074696f6e732e70726f746f12066b6f696e6f731a20676f6f676c652f70726f746f6275662f64657363726970746f722e70726f746f2a6d0a0a62797465735f74797065120a0a064241534536341000120a0a06424153453538100112070a034845581002120c0a08424c4f434b5f4944100312120a0e5452414e53414354494f4e5f49441004120f0a0b434f4e54524143545f49441005120b0a074144445245535310063a4c0a056274797065121d2e676f6f676c652e70726f746f6275662e4669656c644f7074696f6e7318d086032001280e32122e6b6f696e6f732e62797465735f7479706552056274797065880101422e5a2c6769746875622e636f6d2f6b6f696e6f732f6b6f696e6f732d70726f746f2d676f6c616e672f6b6f696e6f73620670726f746f330aa8190a1e6b6f696e6f732f70726f746f636f6c2f70726f746f636f6c2e70726f746f120f6b6f696e6f732e70726f746f636f6c1a146b6f696e6f732f6f7074696f6e732e70726f746f2290010a0a6576656e745f64617461121a0a0873657175656e636518012001280d520873657175656e6365121c0a06736f7572636518022001280c420480b518055206736f7572636512120a046e616d6518032001280952046e616d6512120a046461746118042001280c52046461746112200a08696d70616374656418052003280c420480b518065208696d706163746564225e0a14636f6e74726163745f63616c6c5f62756e646c6512250a0b636f6e74726163745f696418012001280c420480b51805520a636f6e74726163744964121f0a0b656e7472795f706f696e7418022001280d520a656e747279506f696e742292010a1273797374656d5f63616c6c5f746172676574121b0a087468756e6b5f696418012001280d480052077468756e6b496412550a1273797374656d5f63616c6c5f62756e646c6518022001280b32252e6b6f696e6f732e70726f746f636f6c2e636f6e74726163745f63616c6c5f62756e646c654800521073797374656d43616c6c42756e646c6542080a067461726765742294020a1975706c6f61645f636f6e74726163745f6f7065726174696f6e12250a0b636f6e74726163745f696418012001280c420480b51805520a636f6e74726163744964121a0a0862797465636f646518022001280c520862797465636f646512100a03616269180320012809520361626912380a18617574686f72697a65735f63616c6c5f636f6e74726163741804200128085216617574686f72697a657343616c6c436f6e7472616374122a0a11617574686f72697a65735f7573655f7263180520012808520f617574686f72697a65735573655263123c0a1a617574686f72697a65735f75706c6f61645f636f6e74726163741806200128085218617574686f72697a657355706c6f6164436f6e747261637422750a1763616c6c5f636f6e74726163745f6f7065726174696f6e12250a0b636f6e74726163745f696418012001280c420480b51805520a636f6e74726163744964121f0a0b656e7472795f706f696e7418022001280d520a656e747279506f696e7412120a046172677318032001280c52046172677322710a197365745f73797374656d5f63616c6c5f6f7065726174696f6e12170a0763616c6c5f696418012001280d520663616c6c4964123b0a0674617267657418022001280b32232e6b6f696e6f732e70726f746f636f6c2e73797374656d5f63616c6c5f7461726765745206746172676574226f0a1d7365745f73797374656d5f636f6e74726163745f6f7065726174696f6e12250a0b636f6e74726163745f696418012001280c420480b51805520a636f6e7472616374496412270a0f73797374656d5f636f6e7472616374180220012808520e73797374656d436f6e747261637422f1020a096f7065726174696f6e12550a0f75706c6f61645f636f6e747261637418012001280b322a2e6b6f696e6f732e70726f746f636f6c2e75706c6f61645f636f6e74726163745f6f7065726174696f6e4800520e75706c6f6164436f6e7472616374124f0a0d63616c6c5f636f6e747261637418022001280b32282e6b6f696e6f732e70726f746f636f6c2e63616c6c5f636f6e74726163745f6f7065726174696f6e4800520c63616c6c436f6e747261637412540a0f7365745f73797374656d5f63616c6c18032001280b322a2e6b6f696e6f732e70726f746f636f6c2e7365745f73797374656d5f63616c6c5f6f7065726174696f6e4800520d73657453797374656d43616c6c12600a137365745f73797374656d5f636f6e747261637418042001280b322e2e6b6f696e6f732e70726f746f636f6c2e7365745f73797374656d5f636f6e74726163745f6f7065726174696f6e4800521173657453797374656d436f6e747261637442040a026f7022d0010a127472616e73616374696f6e5f68656164657212190a08636861696e5f696418012001280c5207636861696e4964121d0a0872635f6c696d697418022001280442023001520772634c696d697412140a056e6f6e636518032001280c52056e6f6e636512320a156f7065726174696f6e5f6d65726b6c655f726f6f7418042001280c52136f7065726174696f6e4d65726b6c65526f6f74121a0a05706179657218052001280c420480b5180652057061796572121a0a05706179656518062001280c420480b518065205706179656522bc010a0b7472616e73616374696f6e12140a02696418012001280c420480b5180452026964123b0a0668656164657218022001280b32232e6b6f696e6f732e70726f746f636f6c2e7472616e73616374696f6e5f6865616465725206686561646572123a0a0a6f7065726174696f6e7318032003280b321a2e6b6f696e6f732e70726f746f636f6c2e6f7065726174696f6e520a6f7065726174696f6e73121e0a0a7369676e61747572657318042003280c520a7369676e61747572657322b2030a137472616e73616374696f6e5f7265636569707412140a02696418012001280c420480b5180452026964121a0a05706179657218022001280c420480b518065205706179657212240a0c6d61785f70617965725f726318032001280442023001520a6d617850617965725263121d0a0872635f6c696d697418042001280442023001520772634c696d6974121b0a0772635f75736564180520012804420230015206726355736564122e0a116469736b5f73746f726167655f7573656418062001280442023001520f6469736b53746f726167655573656412380a166e6574776f726b5f62616e6477696474685f757365641807200128044202300152146e6574776f726b42616e6477696474685573656412380a16636f6d707574655f62616e6477696474685f75736564180820012804420230015214636f6d7075746542616e64776964746855736564121a0a0872657665727465641809200128085208726576657274656412330a066576656e7473180a2003280b321b2e6b6f696e6f732e70726f746f636f6c2e6576656e745f6461746152066576656e747312120a046c6f6773180b2003280952046c6f677322fb010a0c626c6f636b5f68656164657212200a0870726576696f757318012001280c420480b51803520870726576696f7573121a0a0668656967687418022001280442023001520668656967687412200a0974696d657374616d7018032001280442023001520974696d657374616d70123b0a1a70726576696f75735f73746174655f6d65726b6c655f726f6f7418042001280c521770726576696f757353746174654d65726b6c65526f6f7412360a177472616e73616374696f6e5f6d65726b6c655f726f6f7418052001280c52157472616e73616374696f6e4d65726b6c65526f6f7412160a067369676e657218062001280c52067369676e657222b4010a05626c6f636b12140a02696418012001280c420480b518035202696412350a0668656164657218022001280b321d2e6b6f696e6f732e70726f746f636f6c2e626c6f636b5f686561646572520668656164657212400a0c7472616e73616374696f6e7318032003280b321c2e6b6f696e6f732e70726f746f636f6c2e7472616e73616374696f6e520c7472616e73616374696f6e73121c0a097369676e617475726518042001280c52097369676e617475726522b3030a0d626c6f636b5f7265636569707412140a02696418012001280c420480b5180352026964121a0a06686569676874180220012804420230015206686569676874122e0a116469736b5f73746f726167655f7573656418032001280442023001520f6469736b53746f726167655573656412380a166e6574776f726b5f62616e6477696474685f757365641804200128044202300152146e6574776f726b42616e6477696474685573656412380a16636f6d707574655f62616e6477696474685f75736564180520012804420230015214636f6d7075746542616e64776964746855736564122a0a1173746174655f6d65726b6c655f726f6f7418062001280c520f73746174654d65726b6c65526f6f7412330a066576656e747318072003280b321b2e6b6f696e6f732e70726f746f636f6c2e6576656e745f6461746152066576656e747312570a147472616e73616374696f6e5f726563656970747318082003280b32242e6b6f696e6f732e70726f746f636f6c2e7472616e73616374696f6e5f7265636569707452137472616e73616374696f6e526563656970747312120a046c6f677318092003280952046c6f677342375a356769746875622e636f6d2f6b6f696e6f732f6b6f696e6f732d70726f746f2d676f6c616e672f6b6f696e6f732f70726f746f636f6c620670726f746f33" );
      entry->set_value( protocol_descriptor );
      *entry->mutable_space() = chain::state::space::metadata();

      std::map< std::string, uint64_t > thunk_compute {
         { "apply_block", 16659 },
         { "apply_call_contract_operation", 487 },
         { "apply_set_system_call_operation", 5986 },
         { "apply_set_system_contract_operation", 4746 },
         { "apply_transaction", 13208 },
         { "apply_upload_contract_operation", 3722 },
         { "call_contract", 4810 },
         { "consume_account_rc", 734 },
         { "consume_block_resources", 729 },
         { "deserialize_message_per_byte", 1 },
         { "deserialize_multihash_base", 1 },
         { "deserialize_multihash_per_byte", 478 },
         { "event", 1361 },
         { "event_per_impacted", 98 },
         { "exit", 10246 },
         { "get_account_nonce", 768 },
         { "get_account_rc", 1046 },
         { "get_block", 1131 },
         { "get_block_field", 1420 },
         { "get_caller", 818 },
         { "get_chain_id", 1116 },
         { "get_arguments", 770 },
         { "get_contract_id", 774 },
         { "get_entry_point", 756 },
         { "get_head_info", 2160 },
         { "get_last_irreversible_block", 759 },
         { "get_next_object", 11071 },
         { "get_object", 1067 },
         { "get_prev_object", 15633 },
         { "get_resource_limits", 1153 },
         { "get_transaction", 1619 },
         { "get_transaction_field", 1518 },
         { "hash", 1573 },
         { "keccak_256_base", 1945 },
         { "keccak_256_per_byte", 1 },
         { "log", 746 },
         { "object_serialization_per_byte", 1 },
         { "post_block_callback", 724 },
         { "post_transaction_callback", 741 },
         { "pre_block_callback", 722 },
         { "pre_transaction_callback", 718 },
         { "process_block_signature", 5085 },
         { "put_object", 1053 },
         { "recover_public_key", 29531 },
         { "remove_object", 908 },
         { "check_authority", 13295 },
         { "check_system_authority", 13357 },
         { "ripemd_160_base", 1596 },
         { "ripemd_160_per_byte", 1 },
         { "set_account_nonce", 753 },
         { "sha1_base", 1137 },
         { "sha1_per_byte", 1 },
         { "sha2_256_base", 1542 },
         { "sha2_256_per_byte", 1 },
         { "sha2_512_base", 1612 },
         { "sha2_512_per_byte", 1 },
         { "verify_account_nonce", 879 },
         { "verify_merkle_root", 1 },
         { "verify_signature", 794 },
         { "verify_vrf_proof", 143804 },
      };

      koinos::chain::compute_bandwidth_registry cbr;

      for ( const auto& [ key, value ] : thunk_compute )
      {
         auto centry = cbr.add_entries();
         centry->set_name( key );
         centry->set_compute( value );
      }

      entry = _genesis_data.add_entries();
      entry->set_key( chain::state::key::compute_bandwidth_registry );
      entry->set_value( util::converter::as< std::string >( cbr ) );
      *entry->mutable_space() = chain::state::space::metadata();

      entry = _genesis_data.add_entries();
      entry->set_key( chain::state::key::block_hash_code );
      entry->set_value( util::converter::as< std::string >( unsigned_varint{ std::underlying_type_t< crypto::multicodec >( crypto::multicodec::sha2_256 ) } ) );
      *entry->mutable_space() = chain::state::space::metadata();

      db.open( temp, [&]( state_db::state_node_ptr root )
      {
         // Write genesis objects into the database
         for ( const auto& entry : _genesis_data.entries() )
         {
            KOINOS_ASSERT(
               root->put_object( entry.space(), entry.key(), &entry.value() ) == entry.value().size(),
               koinos::chain::unexpected_state,
               "encountered unexpected object in initial state"
            );
         }
         LOG(info) << "Wrote " << _genesis_data.entries().size() << " genesis objects into new database";

         // Read genesis public key from the database, assert its existence at the correct location
         KOINOS_ASSERT(
            root->get_object( chain::state::space::metadata(), chain::state::key::genesis_key ),
            koinos::chain::unexpected_state,
            "could not find genesis public key in database"
         );

         // Calculate and write the chain ID into the database
         auto chain_id = crypto::hash( koinos::crypto::multicodec::sha2_256, _genesis_data );
         LOG(info) << "Calculated chain ID: " << chain_id;
         auto chain_id_str = util::converter::as< std::string >( chain_id );
         KOINOS_ASSERT(
            root->put_object( chain::state::space::metadata(), chain::state::key::chain_id, &chain_id_str ) == chain_id_str.size(),
            koinos::chain::unexpected_state,
            "encountered unexpected chain id in initial state"
         );
         LOG(info) << "Wrote chain ID into new database";
      } );

      ctx.set_state_node( db.create_writable_node( db.get_head()->id(), crypto::hash( crypto::multicodec::sha2_256, 1 ) ) );
      ctx.reset_cache();
      ctx.push_frame( chain::stack_frame {
         .contract_id = "thunk_tests"s,
         .call_privilege = chain::privilege::kernel_mode
      } );

      ctx.resource_meter().set_resource_limit_data( chain::system_call::get_resource_limits( ctx ) );

      vm_backend->initialize();
   }

   ~thunk_fixture()
   {
      boost::log::core::get()->remove_all_sinks();
      db.close();
      std::filesystem::remove_all( temp );
   }

   void set_transaction_merkle_roots( protocol::transaction& transaction, crypto::multicodec code, crypto::digest_size size = crypto::digest_size( 0 ) )
   {
      std::vector< crypto::multihash > operations;
      operations.reserve( transaction.operations().size() );

      for ( const auto& op : transaction.operations() )
      {
         operations.emplace_back( crypto::hash( code, op, size ) );
      }

      auto operation_merkle_tree = crypto::merkle_tree( code, operations );
      transaction.mutable_header()->set_operation_merkle_root( util::converter::as< std::string >( operation_merkle_tree.root()->hash() ) );
   }

   void sign_transaction( protocol::transaction& transaction, crypto::private_key& transaction_signing_key )
   {
      // Signature is on the hash of the active data
      transaction.mutable_header()->set_payer( transaction_signing_key.get_public_key().to_address_bytes() );
      auto id_mh = crypto::hash( crypto::multicodec::sha2_256, transaction.header() );
      transaction.set_id( util::converter::as< std::string >( id_mh ) );
      transaction.clear_signatures();
      transaction.add_signatures( util::converter::as< std::string >( transaction_signing_key.sign_compact( id_mh ) ) );
   }

   void set_block_merkle_roots( protocol::block& block, crypto::multicodec code, crypto::digest_size size = crypto::digest_size( 0 ) )
   {
      std::vector< crypto::multihash > hashes;
      hashes.reserve( block.transactions().size() * 2 );

      for ( const auto& trx : block.transactions() )
      {
         hashes.emplace_back( crypto::hash( code, trx.header(), size ) );
         hashes.emplace_back( crypto::hash( code, trx.signatures(), size ) );
      }

      auto transaction_merkle_tree = crypto::merkle_tree( code, hashes );
      block.mutable_header()->set_transaction_merkle_root( util::converter::as< std::string >( transaction_merkle_tree.root()->hash() ) );
   }

   std::filesystem::path temp;
   koinos::state_db::database db;
   std::shared_ptr< koinos::vm_manager::vm_backend > vm_backend;
   koinos::chain::execution_context ctx;
   koinos::chain::host_api host;
   koinos::crypto::private_key _signing_private_key;
   chain::genesis_data _genesis_data;
};

enum token_entry : uint32_t
{
   name         = 0x82a3537f,
   symbol       = 0xb76a7ca1,
   decimals     = 0xee80fd2f,
   total_supply = 0xb0da3934,
   balance_of   = 0x5c721497,
   transfer     = 0x27f576ca,
   mint         = 0xdc6f17bb
};

namespace koinos::chain::thunk {

void test_thunk( execution_context& ctx, const std::string& s )
{
   thunk::_log( ctx, "thunk: " + s );
}

} // koinos::chain::thunk

BOOST_FIXTURE_TEST_SUITE( thunk_tests, thunk_fixture )

BOOST_AUTO_TEST_CASE( get_transaction_field )
{ try {
   koinos::protocol::transaction trx;

   koinos::contracts::token::transfer_arguments xfer_arg;
   xfer_arg.set_from( _signing_private_key.get_public_key().to_address_bytes() );
   xfer_arg.set_to( _signing_private_key.get_public_key().to_address_bytes() );
   xfer_arg.set_value( 100 );

   auto op = trx.add_operations()->mutable_call_contract();
   op->set_contract_id( util::from_hex< std::string >( "0xDEADBEEF" ) );
   op->set_entry_point( token_entry::transfer );
   op->set_args( xfer_arg.SerializeAsString() );
   trx.mutable_header()->set_rc_limit( 10'000'000 );
   trx.mutable_header()->set_nonce( util::converter::as< std::string>( uint64_t( 12 ) ) );
   trx.mutable_header()->set_payer( util::from_hex< std::string >( "0x1234" ) );
   trx.mutable_header()->set_payee( util::from_hex< std::string >( "0xABCD" ) );
   set_transaction_merkle_roots( trx, koinos::crypto::multicodec::sha2_256 );
   trx.set_id( util::converter::as< std::string >( crypto::hash( crypto::multicodec::sha2_256, trx.header() ) ) );
   sign_transaction( trx, _signing_private_key );
   ctx.set_transaction( trx );

   BOOST_TEST_MESSAGE( "Testing dynamic transaction field retrieval" );

   koinos::chain::value_type val;

   BOOST_TEST_MESSAGE( "Retrieving ID" );
   val = koinos::chain::system_call::get_transaction_field( ctx, "id" );
   BOOST_REQUIRE_EQUAL( val.bytes_value(), trx.id() );

   BOOST_TEST_MESSAGE( "Retrieving header" );
   val = koinos::chain::system_call::get_transaction_field( ctx, "header" );
   BOOST_REQUIRE( val.has_message_value() );
   koinos::protocol::transaction_header hdr;
   val.message_value().UnpackTo( &hdr );
   BOOST_REQUIRE( google::protobuf::util::MessageDifferencer::Equals( hdr, trx.header() ) );

   BOOST_TEST_MESSAGE( "Retrieving header.rc_limit" );
   val = koinos::chain::system_call::get_transaction_field( ctx, "header.rc_limit" );
   BOOST_REQUIRE_EQUAL( val.uint64_value(), trx.header().rc_limit() );

   BOOST_TEST_MESSAGE( "Retrieving header.nonce" );
   val = koinos::chain::system_call::get_transaction_field( ctx, "header.nonce" );
   BOOST_REQUIRE_EQUAL( val.bytes_value(), trx.header().nonce() );

   BOOST_TEST_MESSAGE( "Retrieving header.operation_merkle_root" );
   val = koinos::chain::system_call::get_transaction_field( ctx, "header.operation_merkle_root" );
   BOOST_REQUIRE_EQUAL( val.bytes_value(), trx.header().operation_merkle_root() );

   BOOST_TEST_MESSAGE( "Retrieving header.payer" );
   val = koinos::chain::system_call::get_transaction_field( ctx, "header.payer" );
   BOOST_REQUIRE_EQUAL( val.bytes_value(), trx.header().payer() );

   BOOST_TEST_MESSAGE( "Retrieving header.payee" );
   val = koinos::chain::system_call::get_transaction_field( ctx, "header.payee" );
   BOOST_REQUIRE_EQUAL( val.bytes_value(), trx.header().payee() );

   BOOST_TEST_MESSAGE( "Retrieving operations" );
   val = koinos::chain::system_call::get_transaction_field( ctx, "operations" );
   BOOST_REQUIRE( val.has_message_value() );
   koinos::chain::list_type list;
   val.message_value().UnpackTo( &list );
   BOOST_REQUIRE_EQUAL( list.values_size(), 1 );
   koinos::protocol::operation op_;
   list.values( 0 ).message_value().UnpackTo( &op_ );
   BOOST_REQUIRE( google::protobuf::util::MessageDifferencer::Equals( op_, trx.operations( 0 ) ) );

   BOOST_TEST_MESSAGE( "Retrieving signatures" );
   val = koinos::chain::system_call::get_transaction_field( ctx, "signatures" );
   val.message_value().UnpackTo( &list );
   for ( int i = 0; i < list.values_size(); i++ )
   {
      BOOST_REQUIRE_EQUAL( trx.signatures( i ), list.values( i ).bytes_value() );
   }

   BOOST_TEST_MESSAGE( "Testing dynamic transaction field not found" );

   BOOST_REQUIRE_THROW( chain::system_call::get_transaction_field( ctx, "non_existent_field" ), chain::field_not_found );

   ctx.clear_transaction();

   BOOST_TEST_MESSAGE( "Testing dynamic transaction field unexpected access" );

   BOOST_REQUIRE_THROW( chain::system_call::get_transaction_field( ctx, "id" ), chain::unexpected_access );

} KOINOS_CATCH_LOG_AND_RETHROW(info) }

BOOST_AUTO_TEST_CASE( get_block_field )
{ try {
   koinos::protocol::block block;

   auto duration = std::chrono::system_clock::now().time_since_epoch();
   block.mutable_header()->set_timestamp( std::chrono::duration_cast< std::chrono::milliseconds >( duration ).count() );
   block.mutable_header()->set_height( 2 );
   block.mutable_header()->set_previous_state_merkle_root( util::converter::as< std::string >( crypto::multihash::zero( crypto::multicodec::sha2_256 ) ) );
   block.mutable_header()->set_previous( util::converter::as< std::string >( crypto::multihash::zero( crypto::multicodec::sha2_256 ) ) );

   koinos::protocol::transaction trx;

   koinos::contracts::token::transfer_arguments xfer_arg;
   xfer_arg.set_from( _signing_private_key.get_public_key().to_address_bytes() );
   xfer_arg.set_to( _signing_private_key.get_public_key().to_address_bytes() );
   xfer_arg.set_value( 100 );

   auto op3 = trx.add_operations()->mutable_call_contract();
   op3->set_contract_id( op3->contract_id() );
   op3->set_entry_point( token_entry::transfer );
   op3->set_args( xfer_arg.SerializeAsString() );
   trx.mutable_header()->set_rc_limit( 10'000'000 );
   trx.mutable_header()->set_nonce( util::converter::as< std::string>( uint64_t( 12 ) ) );
   trx.mutable_header()->set_payer( util::from_hex< std::string >( "0x1234" ) );
   trx.mutable_header()->set_payee( util::from_hex< std::string >( "0xABCD" ) );
   set_transaction_merkle_roots( trx, koinos::crypto::multicodec::sha2_256 );
   trx.set_id( util::converter::as< std::string >( crypto::hash( crypto::multicodec::sha2_256, trx.header() ) ) );
   sign_transaction( trx, _signing_private_key );

   *block.add_transactions() = trx;

   ctx.set_block( block );

   BOOST_TEST_MESSAGE( "Testing dynamic block field retrieval" );

   koinos::chain::value_type val;

   BOOST_TEST_MESSAGE( "Retrieving ID" );
   val = koinos::chain::system_call::get_block_field( ctx, "id" );
   BOOST_REQUIRE_EQUAL( val.bytes_value(), block.id() );

   BOOST_TEST_MESSAGE( "Retrieving header" );
   val = koinos::chain::system_call::get_block_field( ctx, "header" );
   BOOST_REQUIRE( val.has_message_value() );
   koinos::protocol::block_header hdr;
   val.message_value().UnpackTo( &hdr );
   BOOST_REQUIRE( google::protobuf::util::MessageDifferencer::Equals( hdr, block.header() ) );

   BOOST_TEST_MESSAGE( "Retrieving header.previous" );
   val = koinos::chain::system_call::get_block_field( ctx, "header.previous" );
   BOOST_REQUIRE_EQUAL( val.bytes_value(), block.header().previous() );

   BOOST_TEST_MESSAGE( "Retrieving header.height" );
   val = koinos::chain::system_call::get_block_field( ctx, "header.height" );
   BOOST_REQUIRE_EQUAL( val.uint64_value(), block.header().height() );

   BOOST_TEST_MESSAGE( "Retrieving header.timestamp" );
   val = koinos::chain::system_call::get_block_field( ctx, "header.timestamp" );
   BOOST_REQUIRE_EQUAL( val.uint64_value(), block.header().timestamp() );

   BOOST_TEST_MESSAGE( "Retrieving header.previous_state_merkle_root" );
   val = koinos::chain::system_call::get_block_field( ctx, "header.previous_state_merkle_root" );
   BOOST_REQUIRE_EQUAL( val.bytes_value(), block.header().previous_state_merkle_root() );

   BOOST_TEST_MESSAGE( "Retrieving header.transaction_merkle_root" );
   val = koinos::chain::system_call::get_block_field( ctx, "header.transaction_merkle_root" );
   BOOST_REQUIRE_EQUAL( val.bytes_value(), block.header().transaction_merkle_root() );

   BOOST_TEST_MESSAGE( "Retrieving header.signer" );
   val = koinos::chain::system_call::get_block_field( ctx, "header.signer" );
   BOOST_REQUIRE_EQUAL( val.bytes_value(), block.header().signer() );

   BOOST_TEST_MESSAGE( "Retrieving transactions" );
   val = koinos::chain::system_call::get_block_field( ctx, "transactions" );
   BOOST_REQUIRE( val.has_message_value() );
   koinos::chain::list_type list;
   val.message_value().UnpackTo( &list );
   BOOST_REQUIRE_EQUAL( list.values_size(), 1 );
   for ( int i = 0; i < list.values_size(); i++ )
   {
      koinos::protocol::transaction tx;
      list.values( i ).message_value().UnpackTo( &tx );
      BOOST_REQUIRE( google::protobuf::util::MessageDifferencer::Equals( block.transactions( i ), tx ) );
   }

   BOOST_TEST_MESSAGE( "Retrieving signature" );
   val = koinos::chain::system_call::get_block_field( ctx, "signature" );
   BOOST_REQUIRE_EQUAL( val.bytes_value(), block.signature() );

   BOOST_TEST_MESSAGE( "Testing dynamic block field not found" );

   BOOST_REQUIRE_THROW( chain::system_call::get_block_field( ctx, "non_existent_field" ), chain::field_not_found );

   ctx.clear_block();

   BOOST_TEST_MESSAGE( "Testing dynamic block field unexpected access" );

   BOOST_REQUIRE_THROW( chain::system_call::get_block_field( ctx, "id" ), chain::unexpected_access );

} KOINOS_CATCH_LOG_AND_RETHROW(info) }

BOOST_AUTO_TEST_CASE( db_crud )
{ try {
   std::string object_data;

   chain::object_space test_space;
   test_space.set_system( true );
   test_space.set_zone( chain::state::zone::kernel );
   test_space.set_id( 100 );

   object_data = "object1"s;

   BOOST_TEST_MESSAGE( "Test putting an object" );

   chain::system_call::put_object( ctx, test_space, util::converter::as< std::string >( 1 ), object_data );
   auto db_obj = chain::system_call::get_object( ctx, test_space, util::converter::as< std::string >( 1 ) );
   BOOST_REQUIRE( object_data == "object1" );

   BOOST_TEST_MESSAGE( "Testing getting a non-existent object" );

   db_obj = chain::system_call::get_object( ctx, test_space, util::converter::as< std::string >( 2 ) );
   BOOST_REQUIRE( !db_obj.exists() );

   BOOST_TEST_MESSAGE( "Test iteration" );

   object_data = "object2"s;
   chain::system_call::put_object( ctx, test_space, util::converter::as< std::string >( 2 ), object_data );
   object_data = "object3"s;
   chain::system_call::put_object( ctx, test_space, util::converter::as< std::string >( 3 ), object_data );

   db_obj = chain::system_call::get_next_object( ctx, test_space, util::converter::as< std::string >( 2 ) );
   BOOST_REQUIRE( db_obj.value() == "object3" );

   db_obj = chain::system_call::get_prev_object( ctx, test_space, util::converter::as< std::string >( 2 ) );
   BOOST_REQUIRE( db_obj.value() == "object1" );

   BOOST_TEST_MESSAGE( "Test iterator overrun" );

   db_obj = chain::system_call::get_next_object( ctx, test_space, util::converter::as< std::string >( 3 ) );
   BOOST_REQUIRE( !db_obj.exists() );
   db_obj = chain::system_call::get_next_object( ctx, test_space, util::converter::as< std::string >( 4 ) );
   BOOST_REQUIRE( !db_obj.exists() );
   db_obj = chain::system_call::get_prev_object( ctx, test_space, util::converter::as< std::string >( 1 ) );
   BOOST_REQUIRE( !db_obj.exists() );
   db_obj = chain::system_call::get_prev_object( ctx, test_space, util::converter::as< std::string >( 0 ) );
   BOOST_REQUIRE( !db_obj.exists() );

   object_data = "space1.object1"s;
   chain::system_call::put_object( ctx, chain::state::space::contract_bytecode(), util::converter::as< std::string >( 1 ), object_data );
   db_obj = chain::system_call::get_next_object( ctx, test_space, util::converter::as< std::string >( 3 ) );
   BOOST_REQUIRE( !db_obj.exists() );
   db_obj = chain::system_call::get_next_object( ctx, chain::state::space::contract_bytecode(), util::converter::as< std::string >( 1 ) );
   BOOST_REQUIRE( !db_obj.exists() );
   db_obj = chain::system_call::get_prev_object( ctx, chain::state::space::contract_bytecode(), util::converter::as< std::string >( 1 ) );
   BOOST_REQUIRE( !db_obj.exists() );

   BOOST_TEST_MESSAGE( "Test object modification" );
   object_data = "object1.1"s;
   chain::system_call::put_object( ctx, test_space, util::converter::as< std::string >( 1 ), object_data );
   db_obj = chain::system_call::get_object( ctx, test_space, util::converter::as< std::string >( 1 ) );
   BOOST_REQUIRE( db_obj.value() == "object1.1" );

   BOOST_TEST_MESSAGE( "Test object deletion" );
   object_data.clear();
   chain::system_call::put_object( ctx, test_space, util::converter::as< std::string >( 1 ), object_data );
   db_obj = chain::system_call::get_object( ctx, test_space, util::converter::as< std::string >( 1 ) );
   BOOST_REQUIRE( db_obj.exists() );
   BOOST_REQUIRE( db_obj.value().size() == 0 );

   chain::system_call::remove_object( ctx, test_space, util::converter::as< std::string >( 1 ) );
   db_obj = chain::system_call::get_object( ctx, test_space, util::converter::as< std::string >( 1 ) );
   BOOST_REQUIRE( !db_obj.exists() );

} KOINOS_CATCH_LOG_AND_RETHROW(info) }

BOOST_AUTO_TEST_CASE( contract_tests )
{ try {
   BOOST_TEST_MESSAGE( "Test uploading a contract" );

   auto contract_private_key = koinos::crypto::private_key::regenerate( koinos::crypto::hash( koinos::crypto::multicodec::sha2_256, "contract"s ) );
   auto contract_address = contract_private_key.get_public_key().to_address_bytes();
   koinos::protocol::transaction trx;
   sign_transaction( trx, contract_private_key );
   ctx.set_transaction( trx );

   koinos::protocol::upload_contract_operation op;
   op.set_contract_id( util::converter::as< std::string >( contract_address ) );
   op.set_bytecode( get_hello_wasm() );

   koinos::chain::system_call::apply_upload_contract_operation( ctx, op );

   auto bytecode_object = koinos::chain::system_call::get_object( ctx, koinos::chain::state::space::contract_bytecode(), op.contract_id() );
   auto meta = util::converter::to< koinos::chain::contract_metadata_object >( koinos::chain::system_call::get_object( ctx, koinos::chain::state::space::contract_metadata(), op.contract_id() ).value() );

   BOOST_REQUIRE( bytecode_object.exists() );
   BOOST_REQUIRE( bytecode_object.value().size() == op.bytecode().size() );
   BOOST_REQUIRE( std::memcmp( bytecode_object.value().c_str(), op.bytecode().c_str(), op.bytecode().size() ) == 0 );
   BOOST_REQUIRE( meta.hash() == util::converter::as< std::string >( koinos::crypto::hash( koinos::crypto::multicodec::sha2_256, bytecode_object.value() ) ) );

   BOOST_TEST_MESSAGE( "Test executing a contract" );

   koinos::protocol::call_contract_operation op2;
   op2.set_contract_id( op.contract_id() );
   koinos::chain::system_call::apply_call_contract_operation( ctx, op2 );
   BOOST_REQUIRE_EQUAL( "Greetings from koinos vm", ctx.chronicler().logs()[0] );

   BOOST_TEST_MESSAGE( "Test contract return" );

   // Upload the return test contract
   op.set_bytecode( get_contract_return_wasm() );
   koinos::chain::system_call::apply_upload_contract_operation( ctx, op );

   auto contract_ret = koinos::chain::system_call::call(ctx, op.contract_id(), 0, "echo").value();

   BOOST_REQUIRE_EQUAL( contract_ret, "echo" );

} KOINOS_CATCH_LOG_AND_RETHROW(info) }

BOOST_AUTO_TEST_CASE( override_tests )
{ try {
   BOOST_TEST_MESSAGE( "Test set system call operation" );

   auto seed = "non-genesis key"s;
   auto random_private_key = koinos::crypto::private_key::regenerate( koinos::crypto::hash( koinos::crypto::multicodec::sha2_256, seed ) );

   koinos::protocol::transaction tx;
   sign_transaction( tx, random_private_key );
   ctx.set_transaction( tx );

   // Upload a test contract to use as override
   auto contract_address = random_private_key.get_public_key().to_address_bytes();

   koinos::protocol::upload_contract_operation contract_op;
   contract_op.set_contract_id( util::converter::as< std::string >( contract_address ) );
   contract_op.set_bytecode( get_hello_wasm() );

   koinos::chain::system_call::apply_upload_contract_operation( ctx, contract_op );

   koinos::protocol::call_contract_operation call_op;
   call_op.set_contract_id( contract_op.contract_id() );
   koinos::chain::system_call::apply_call_contract_operation( ctx, call_op );
   auto original_message = host._ctx.chronicler().logs()[0];
   for ( const auto& message : host._ctx.chronicler().logs() )
      LOG(info) << message;
   BOOST_REQUIRE_EQUAL( "Greetings from koinos vm", original_message );

   // Override log with a contract that prepends a message before printing
   auto random_private_key2 = koinos::crypto::private_key::regenerate( koinos::crypto::hash( koinos::crypto::multicodec::sha2_256, "key2"s ) );
   auto contract_address2 = random_private_key2.get_public_key().to_address_bytes();

   koinos::protocol::upload_contract_operation contract_op2;
   contract_op2.set_contract_id( util::converter::as< std::string >( contract_address2 ) );
   contract_op2.set_bytecode( get_syscall_override_wasm() );

   sign_transaction( tx, random_private_key2 );
   ctx.set_transaction( tx );

   koinos::chain::system_call::apply_upload_contract_operation( ctx, contract_op2 );

   // Set the system call
   koinos::protocol::set_system_call_operation set_op;
   set_op.set_call_id( std::underlying_type_t< chain::system_call_id >( chain::system_call_id::log ) );
   set_op.mutable_target()->mutable_system_call_bundle()->set_contract_id( contract_op2.contract_id() );
   set_op.mutable_target()->mutable_system_call_bundle()->set_entry_point( 0 );

   BOOST_TEST_MESSAGE( "Test failure to override system call without genesis key" );

   BOOST_REQUIRE_THROW( koinos::chain::system_call::apply_set_system_call_operation( ctx, set_op ), koinos::chain::authorization_failed );

   BOOST_TEST_MESSAGE( "Test failure to set system contract without genesis key" );

   koinos::protocol::set_system_contract_operation system_contract_op;
   system_contract_op.set_contract_id( contract_op2.contract_id() );
   system_contract_op.set_system_contract( true );

   BOOST_REQUIRE_THROW( koinos::chain::system_call::apply_set_system_contract_operation( ctx, system_contract_op ), koinos::chain::authorization_failed );

   BOOST_TEST_MESSAGE( "Test failure to override system call without system contract" );

   // Overriding system calls requires the genesis key
   sign_transaction( tx, _signing_private_key );
   ctx.set_transaction( tx );

   BOOST_REQUIRE_THROW( koinos::chain::system_call::apply_set_system_call_operation( ctx, set_op ), koinos::chain::invalid_contract );

   BOOST_TEST_MESSAGE( "Test success overriding a system call with the genesis key" );

   koinos::chain::system_call::apply_set_system_contract_operation( ctx, system_contract_op );
   koinos::chain::system_call::apply_set_system_call_operation( ctx, set_op );

   // Fetch the created call bundle from the database and check it has been updated
   auto call_target = koinos::util::converter::to< koinos::protocol::system_call_target >( koinos::chain::system_call::get_object( ctx, koinos::chain::state::space::system_call_dispatch(), util::converter::as< std::string >( set_op.call_id() ) ).value() );
   BOOST_REQUIRE( call_target.has_system_call_bundle() );
   ctx.set_state_node( ctx.get_state_node()->create_anonymous_node() );
   ctx.reset_cache();
   call_target = koinos::util::converter::to< koinos::protocol::system_call_target >( koinos::chain::system_call::get_object( ctx, koinos::chain::state::space::system_call_dispatch(), util::converter::as< std::string >( set_op.call_id() ) ).value() );
   BOOST_REQUIRE( call_target.has_system_call_bundle() );
   BOOST_REQUIRE( call_target.system_call_bundle().contract_id() == set_op.target().system_call_bundle().contract_id() );
   BOOST_REQUIRE( call_target.system_call_bundle().entry_point() == set_op.target().system_call_bundle().entry_point() );

   // Ensure exception thrown on invalid contract
   auto false_id = koinos::crypto::hash( koinos::crypto::multicodec::ripemd_160, 1234 );
   set_op.mutable_target()->mutable_system_call_bundle()->set_contract_id( util::converter::as< std::string >( false_id ) );
   BOOST_REQUIRE_THROW( koinos::chain::system_call::apply_set_system_call_operation( ctx, set_op ), koinos::chain::invalid_contract );

   // Test invoking the overridden system call
   koinos::chain::system_call::apply_call_contract_operation( ctx, call_op );
   BOOST_REQUIRE_EQUAL( "test: " + original_message, host._ctx.chronicler().logs()[1] );

   koinos::chain::system_call::log( host._ctx, "Hello World" );
   BOOST_REQUIRE_EQUAL( "test: Hello World", host._ctx.chronicler().logs()[2] );

   BOOST_TEST_MESSAGE( "Test adding a new thunk" );

   const_cast< chain::thunk_dispatcher& >( chain::thunk_dispatcher::instance() ).register_thunk< chain::log_arguments, chain::log_result >( 0, chain::thunk::test_thunk );
   chain::log_arguments log_args;
   log_args.set_message( "Hello World" );
   auto args = util::converter::as< std::string >( log_args );
   char ret_buf[100];
   BOOST_CHECK_THROW( host.invoke_system_call( 0, ret_buf, 100, args.data(), args.size() ), chain::thunk_not_enabled );

   BOOST_TEST_MESSAGE( "Test overriding a system call with another thunk" );

   set_op.set_call_id( std::underlying_type_t< chain::system_call_id >( chain::system_call_id::log ) );
   set_op.mutable_target()->set_thunk_id( 0 );
   koinos::chain::system_call::apply_set_system_call_operation( ctx, set_op );
   ctx.set_state_node( ctx.get_state_node()->create_anonymous_node() );
   ctx.reset_cache();

   BOOST_CHECK_THROW( koinos::chain::system_call::log( host._ctx, "Hello World" ), chain::unexpected_state );

   auto cbr = util::converter::to< chain::compute_bandwidth_registry >( chain::system_call::get_object( ctx, chain::state::space::metadata(), chain::state::key::compute_bandwidth_registry ).value() );
   auto centry = cbr.add_entries();
   centry->set_name( "reserved_id" );
   centry->set_compute( 0 );

   chain::system_call::put_object( ctx, chain::state::space::metadata(), chain::state::key::compute_bandwidth_registry, util::converter::as< std::string >( cbr ) );
   ctx.set_state_node( ctx.get_state_node()->create_anonymous_node() );
   ctx.reset_cache();

   koinos::chain::system_call::log( host._ctx, "Hello World" );
   BOOST_REQUIRE_EQUAL( "thunk: Hello World", host._ctx.chronicler().logs()[3] );

   host.invoke_system_call( chain::system_call_id::log, ret_buf, 100, args.data(), args.size() );
   BOOST_CHECK_THROW( host.invoke_system_call( 0, ret_buf, 100, args.data(), args.size() ), chain::thunk_not_enabled );

   BOOST_TEST_MESSAGE( "Test enabling new thunk passthrough" );

   set_op.set_call_id( std::underlying_type_t< chain::system_call_id >( chain::system_call_id::reserved_id ) );
   koinos::chain::system_call::apply_set_system_call_operation( ctx, set_op );
   ctx.set_state_node( ctx.get_state_node()->create_anonymous_node() );
   ctx.reset_cache();

   host.invoke_system_call( 0, ret_buf, 100, args.data(), args.size() );

} KOINOS_CATCH_LOG_AND_RETHROW(info) }

BOOST_AUTO_TEST_CASE( thunk_test )
{ try {
   BOOST_TEST_MESSAGE( "thunk test" );

   chain::log_arguments args;

   std::string arg;
   std::string ret;

   args.set_message( "Hello World" );
   args.SerializeToString( &arg );

   host.invoke_thunk(
      chain::system_call_id::log,
      ret.data(),
      ret.size(),
      arg.data(),
      arg.size()
   );

   BOOST_CHECK_EQUAL( ret.size(), 0 );
   BOOST_REQUIRE_EQUAL( "Hello World", ctx.chronicler().logs()[0] );

   ctx.push_frame( chain::stack_frame{ .contract_id = "user_contract", .call_privilege = chain::user_mode } );
   BOOST_REQUIRE_THROW( host.invoke_thunk( chain::system_call_id::log, ret.data(), ret.size(), arg.data(), arg.size() ), chain::insufficient_privileges );
} KOINOS_CATCH_LOG_AND_RETHROW(info) }

BOOST_AUTO_TEST_CASE( system_call_test )
{ try {
   BOOST_TEST_MESSAGE( "system call test" );

   chain::log_arguments args;

   std::string arg;
   std::string ret;

   args.set_message( "Hello World" );
   args.SerializeToString( &arg );

   host.invoke_system_call(
      chain::system_call_id::log,
      ret.data(),
      ret.size(),
      arg.data(),
      arg.size()
   );

   BOOST_CHECK_EQUAL( ret.size(), 0 );
   BOOST_REQUIRE_EQUAL( "Hello World", ctx.chronicler().logs()[0] );
} KOINOS_CATCH_LOG_AND_RETHROW(info) }

BOOST_AUTO_TEST_CASE( get_head_info_thunk_test )
{ try {
   BOOST_TEST_MESSAGE( "get_head_info thunk test" );

   BOOST_CHECK_EQUAL( chain::system_call::get_head_info( ctx ).head_topology().height(), 1 );

   koinos::protocol::block block;
   block.mutable_header()->set_timestamp( 1000 );
   ctx.set_block( block );

   BOOST_REQUIRE( chain::system_call::get_head_info( ctx ).head_block_time() == block.header().timestamp() );

   ctx.clear_block();

   chain::system_call::put_object( ctx, chain::state::space::metadata(), chain::state::key::head_block, util::converter::as< std::string >( block ) );

   BOOST_REQUIRE( chain::system_call::get_head_info( ctx ).head_block_time() == block.header().timestamp() );

} KOINOS_CATCH_LOG_AND_RETHROW(info) }

BOOST_AUTO_TEST_CASE( hash_thunk_test )
{ try {
   BOOST_TEST_MESSAGE( "hash thunk test" );

   std::string test_string = "hash::string";

   auto thunk_hash  = util::converter::to< crypto::multihash >( chain::system_call::hash( ctx, static_cast< uint64_t >( crypto::multicodec::sha2_256 ), test_string ) );
   auto native_hash = crypto::hash( crypto::multicodec::sha2_256, test_string );

   BOOST_CHECK_EQUAL( thunk_hash, native_hash );

   koinos::block_topology block_topology;
   block_topology.set_height( 100 );
   block_topology.set_id( util::converter::as< std::string >( crypto::hash( crypto::multicodec::sha2_256, "random::id"s ) ) );
   block_topology.set_previous( util::converter::as< std::string >( crypto::hash( crypto::multicodec::sha2_256, "random::previous"s ) ) );

   std::string blob;
   block_topology.SerializeToString( &blob );
   thunk_hash = util::converter::to< crypto::multihash >( chain::system_call::hash( ctx, static_cast< uint64_t >( crypto::multicodec::sha2_256 ), blob ) );
   native_hash = crypto::hash( crypto::multicodec::sha2_256, block_topology );

   BOOST_CHECK_EQUAL( thunk_hash, native_hash );

   BOOST_REQUIRE_THROW( chain::system_call::hash( ctx, 0xDEADBEEF /* unknown code */, blob ), koinos::chain::unknown_hash_code );

} KOINOS_CATCH_LOG_AND_RETHROW(info) }

BOOST_AUTO_TEST_CASE( privileged_calls )
{
   ctx.set_privilege( chain::privilege::user_mode );
   BOOST_REQUIRE_THROW( chain::system_call::apply_block( ctx, protocol::block{} ), koinos::chain::insufficient_privileges );
   BOOST_REQUIRE_THROW( chain::system_call::apply_transaction( ctx, protocol::transaction() ), koinos::chain::insufficient_privileges );
   BOOST_REQUIRE_THROW( chain::system_call::apply_upload_contract_operation( ctx, protocol::upload_contract_operation{} ), koinos::chain::insufficient_privileges );
   BOOST_REQUIRE_THROW( chain::system_call::apply_call_contract_operation( ctx, protocol::call_contract_operation{} ), koinos::chain::insufficient_privileges );
   BOOST_REQUIRE_THROW( chain::system_call::apply_set_system_call_operation( ctx, protocol::set_system_call_operation{} ), koinos::chain::insufficient_privileges );
   BOOST_REQUIRE_THROW( chain::system_call::apply_set_system_contract_operation( ctx, protocol::set_system_contract_operation{} ), koinos::chain::insufficient_privileges );
}

BOOST_AUTO_TEST_CASE( last_irreversible_block_test )
{ try {

   BOOST_TEST_MESSAGE( "last irreversible block test" );

   for( uint64_t i = 0; i < chain::default_irreversible_threshold; i++ )
   {
      auto lib = chain::system_call::get_last_irreversible_block( ctx );
      BOOST_REQUIRE_EQUAL( lib, 0 );

      db.finalize_node( ctx.get_state_node()->id() );
      ctx.set_state_node( db.create_writable_node( ctx.get_state_node()->id(), crypto::hash( crypto::multicodec::sha2_256, i ) ) );
   }

   auto lib = chain::system_call::get_last_irreversible_block( ctx );
   BOOST_REQUIRE_EQUAL( lib, 1 );

} KOINOS_CATCH_LOG_AND_RETHROW(info) }

BOOST_AUTO_TEST_CASE( stack_tests )
{ try {
   BOOST_TEST_MESSAGE( "apply context stack tests" );
   ctx.pop_frame();

   BOOST_REQUIRE_THROW( ctx.pop_frame(), chain::stack_exception );

   auto call1 = util::converter::as< std::string >( crypto::hash( crypto::multicodec::ripemd_160, "call1"s ) );
   ctx.push_frame( chain::stack_frame{ .contract_id = call1 } );
   BOOST_CHECK_EQUAL( "", ctx.get_caller() );
   BOOST_CHECK_EQUAL( call1, ctx.get_contract_id() );

   auto call2 = util::converter::as< std::string >( crypto::hash( crypto::multicodec::ripemd_160, "call2"s ) );
   ctx.push_frame( chain::stack_frame{ .contract_id = call2 } );

   BOOST_CHECK_EQUAL( call1, ctx.get_caller() );
   BOOST_CHECK_EQUAL( call2, ctx.get_contract_id() );

   auto last_frame = ctx.pop_frame();
   BOOST_CHECK_EQUAL( call2, last_frame.contract_id );
   BOOST_CHECK_EQUAL( "", ctx.get_caller() );

   for ( int i = 2; i <= chain::execution_context::stack_limit; i++ )
   {
      ctx.push_frame( chain::stack_frame{} );
   }

   BOOST_REQUIRE_THROW( ctx.push_frame( chain::stack_frame{} ), chain::stack_overflow );

} KOINOS_CATCH_LOG_AND_RETHROW(info) }

BOOST_AUTO_TEST_CASE( check_authority )
{ try {
   auto foo_key = crypto::private_key::regenerate( crypto::hash( crypto::multicodec::sha2_256, "foo"s ) );
   auto foo_account_string = foo_key.get_public_key().to_address_bytes();

   auto bar_key = crypto::private_key::regenerate( crypto::hash( crypto::multicodec::sha2_256, "bar"s ) );
   auto bar_account_string = bar_key.get_public_key().to_address_bytes();

   protocol::transaction trx;
   sign_transaction( trx, foo_key );
   ctx.set_transaction( trx );

   chain::system_call::check_authority( ctx, koinos::chain::contract_call, foo_account_string );

   BOOST_REQUIRE_THROW( chain::system_call::check_authority( ctx, koinos::chain::contract_call, bar_account_string ), chain::authorization_failed );

   trx.clear_signatures();
   BOOST_REQUIRE_THROW( chain::system_call::check_authority( ctx, koinos::chain::contract_call, foo_account_string ), chain::authorization_failed );

} KOINOS_CATCH_LOG_AND_RETHROW(info) }

BOOST_AUTO_TEST_CASE( transaction_nonce_test )
{ try {
   using namespace koinos;

   ctx.set_intent( chain::intent::transaction_application );

   BOOST_TEST_MESSAGE( "Test transaction nonce" );

   auto key = crypto::private_key::regenerate( crypto::hash( crypto::multicodec::sha2_256, "alpha bravo charlie delta"s ) );

   protocol::transaction transaction;

   koinos::chain::value_type nonce_value;
   nonce_value.set_uint64_value( 1 );

   transaction.mutable_header()->set_rc_limit( 1'000'000 );
   transaction.mutable_header()->set_nonce( util::converter::as< std::string>( nonce_value ) );
   transaction.mutable_header()->set_payer( key.get_public_key().to_address_bytes() );
   transaction.mutable_header()->set_chain_id( koinos::chain::system_call::get_object( ctx, chain::state::space::metadata(), chain::state::key::chain_id ).value() );
   set_transaction_merkle_roots( transaction, crypto::multicodec::sha2_256 );
   sign_transaction( transaction, key );

   chain::system_call::apply_transaction( ctx, transaction );

   auto payer = transaction.header().payer();
   auto nonce = chain::system_call::get_account_nonce( ctx, payer );
   BOOST_REQUIRE_EQUAL( nonce, util::converter::as< std::string >( nonce_value ) );

   BOOST_TEST_MESSAGE( "Test duplicate transaction nonce" );
   transaction.mutable_header()->set_rc_limit( 1'000'000 );
   transaction.mutable_header()->set_nonce( util::converter::as< std::string>( nonce_value ) );
   set_transaction_merkle_roots( transaction, crypto::multicodec::sha2_256 );
   sign_transaction( transaction, key );

   BOOST_REQUIRE_THROW( chain::system_call::apply_transaction( ctx, transaction ), chain::chain_exception );

   nonce = chain::system_call::get_account_nonce( ctx, payer );
   BOOST_REQUIRE_EQUAL( nonce, util::converter::as< std::string >( nonce_value ) );

   BOOST_TEST_MESSAGE( "Test next transaction nonce" );
   nonce_value.set_uint64_value( 2 );
   transaction.mutable_header()->set_nonce( util::converter::as< std::string>( nonce_value ) );
   set_transaction_merkle_roots( transaction, crypto::multicodec::sha2_256 );
   sign_transaction( transaction, key );

   chain::system_call::apply_transaction( ctx, transaction );

   nonce = chain::system_call::get_account_nonce( ctx, payer );
   BOOST_REQUIRE_EQUAL( nonce, util::converter::as< std::string >( nonce_value ) );

   BOOST_TEST_MESSAGE( "Test duplicate transaction nonce" );
   transaction.mutable_header()->set_rc_limit( 1'000'000 );
   set_transaction_merkle_roots( transaction, crypto::multicodec::sha2_256 );
   sign_transaction( transaction, key );

   BOOST_REQUIRE_THROW( chain::system_call::apply_transaction( ctx, transaction ), chain::chain_exception );

   nonce = chain::system_call::get_account_nonce( ctx, payer );
   BOOST_REQUIRE_EQUAL( nonce, util::converter::as< std::string >( nonce_value ) );

   BOOST_TEST_MESSAGE( "Test skipping transaction nonce" );
   nonce_value.set_uint64_value( 10 );
   transaction.mutable_header()->set_nonce( util::converter::as< std::string>( nonce_value ) );
   set_transaction_merkle_roots( transaction, crypto::multicodec::sha2_256 );
   sign_transaction( transaction, key );

   chain::system_call::apply_transaction( ctx, transaction );

   nonce = chain::system_call::get_account_nonce( ctx, payer );
   BOOST_REQUIRE( nonce_value.ParseFromString( nonce ) );
   BOOST_REQUIRE_EQUAL( nonce_value.uint64_value(), uint64_t( 10 ) );

   BOOST_TEST_MESSAGE( "Test old nonce" );
   nonce_value.set_uint64_value( 5 );
   transaction.mutable_header()->set_nonce( util::converter::as< std::string >( nonce_value ) );
   set_transaction_merkle_roots( transaction, crypto::multicodec::sha2_256 );
   sign_transaction( transaction, key );

   BOOST_REQUIRE_THROW( chain::system_call::apply_transaction( ctx, transaction ), chain::chain_exception );
} KOINOS_CATCH_LOG_AND_RETHROW(info) }

BOOST_AUTO_TEST_CASE( get_contract_id_test )
{ try {
   auto contract_id = util::converter::as< std::string >( crypto::hash( crypto::multicodec::ripemd_160, "get_contract_id_test"s ) );

   ctx.push_frame( chain::stack_frame {
      .contract_id = contract_id,
      .call_privilege = chain::privilege::kernel_mode
   } );

   auto id = chain::system_call::get_contract_id( ctx );

   BOOST_REQUIRE_EQUAL( contract_id, id );
   //BOOST_REQUIRE( contract_id.size() == id.size() );
   //auto id_bytes = util::converter::as< std::vector< std::byte > >( id );
   //BOOST_REQUIRE( std::equal( contract_id.begin(), contract_id.end(), id_bytes.begin() ) );
} KOINOS_CATCH_LOG_AND_RETHROW(info) }

BOOST_AUTO_TEST_CASE( token_tests )
{ try {
   using namespace koinos;

   auto contract_private_key = crypto::private_key::regenerate( crypto::hash( koinos::crypto::multicodec::sha2_256, "token_contract"s ) );
   auto contract_address = contract_private_key.get_public_key().to_address_bytes();
   protocol::transaction trx;
   sign_transaction( trx, contract_private_key );
   ctx.set_transaction( trx );

   koinos::protocol::upload_contract_operation op;
   op.set_contract_id( util::converter::as< std::string >( contract_address ) );
   op.set_bytecode( get_koin_wasm() );

   koinos::chain::system_call::apply_upload_contract_operation( ctx, op );

   BOOST_TEST_MESSAGE( "Test executing a contract" );

   ctx.push_frame( chain::stack_frame{ .contract_id = "token_tests"s, .call_privilege = chain::user_mode } );

   auto response = koinos::chain::system_call::call( ctx, op.contract_id(), token_entry::name, "" ).value();
   auto name = util::converter::to< koinos::contracts::token::name_result >( response );
   LOG(info) << name.value();

   response = koinos::chain::system_call::call( ctx, op.contract_id(), token_entry::symbol, "" ).value();
   auto symbol = util::converter::to< koinos::contracts::token::symbol_result >( response );
   LOG(info) << symbol.value();

   response = koinos::chain::system_call::call( ctx, op.contract_id(), token_entry::decimals, "" ).value();
   auto decimals = util::converter::to< koinos::contracts::token::decimals_result >( response );
   LOG(info) << decimals.value();

   response = koinos::chain::system_call::call( ctx, op.contract_id(), token_entry::total_supply, "" ).value();
   auto supply = util::converter::to< koinos::contracts::token::total_supply_result >( response );
   LOG(info) << "KOIN supply: " << supply.value();

   auto alice_private_key = crypto::private_key::regenerate( koinos::crypto::hash( koinos::crypto::multicodec::sha2_256, "alice"s ) );
   auto alice_address = alice_private_key.get_public_key().to_address_bytes();

   auto bob_private_key = crypto::private_key::regenerate( koinos::crypto::hash( koinos::crypto::multicodec::sha2_256, "bob"s ) );
   auto bob_address = bob_private_key.get_public_key().to_address_bytes();

   koinos::contracts::token::balance_of_arguments balance_of_args;
   balance_of_args.set_owner( util::converter::as< std::string >( alice_address ) );
   response = koinos::chain::system_call::call( ctx, op.contract_id(), token_entry::balance_of, util::converter::as< std::string >( balance_of_args ) ).value();
   auto balance = util::converter::to< koinos::contracts::token::balance_of_result >( response );
   LOG(info) << "'alice' balance: " << balance.value();

   balance_of_args.set_owner( util::converter::as< std::string >( bob_address ) );
   response = koinos::chain::system_call::call( ctx, op.contract_id(), token_entry::balance_of, util::converter::as< std::string >( balance_of_args ) ).value();
   balance = util::converter::to< koinos::contracts::token::balance_of_result >( response );
   LOG(info) << "'bob' balance: " << balance.value();

   auto session = ctx.make_session( 1'000'000 );

   LOG(info) << "Mint to 'alice'";
   koinos::contracts::token::mint_arguments mint_args;
   mint_args.set_to( util::converter::as< std::string >( alice_address ) );
   mint_args.set_value( 100 );

   response = koinos::chain::system_call::call( ctx, op.contract_id(), token_entry::mint, util::converter::as< std::string >( mint_args ) ).value();
   auto success = util::converter::to< koinos::contracts::token::mint_result >( response );
   BOOST_REQUIRE( !success.value() );
   BOOST_CHECK_EQUAL( session->events().size(), 0 );

   session = ctx.make_session( 1'000'000 );

   ctx.set_privilege( chain::privilege::kernel_mode );
   response = koinos::chain::system_call::call( ctx, op.contract_id(), token_entry::mint, util::converter::as< std::string >( mint_args ) ).value();
   success = util::converter::to< koinos::contracts::token::mint_result >( response );
   BOOST_REQUIRE( success.value() );

   BOOST_REQUIRE_EQUAL( session->events().size(), 1 );
   {
      const auto& event = session->events()[0];
      BOOST_CHECK_EQUAL( event.source(), op.contract_id() );
      BOOST_CHECK_EQUAL( event.name(), "koin.mint" );
      BOOST_CHECK_EQUAL( event.impacted().size(), 1 );
      BOOST_CHECK_EQUAL( event.impacted()[0], mint_args.to() );

      auto mint_event = util::converter::to< koinos::contracts::token::mint_event >( event.data() );
      BOOST_CHECK_EQUAL( mint_event.to(), mint_args.to() );
      BOOST_CHECK_EQUAL( mint_event.value(), mint_args.value() );
   }

   ctx.set_privilege( chain::privilege::user_mode );
   balance_of_args.set_owner( util::converter::as< std::string >( alice_address ) );
   response = koinos::chain::system_call::call( ctx, op.contract_id(), token_entry::balance_of, util::converter::as< std::string >( balance_of_args ) ).value();
   balance = util::converter::to< koinos::contracts::token::balance_of_result >( response );

   LOG(info) << "'alice' balance: " << balance.value();

   balance_of_args.set_owner( util::converter::as< std::string >( bob_address ) );
   response = koinos::chain::system_call::call( ctx, op.contract_id(), token_entry::balance_of, util::converter::as< std::string >( balance_of_args ) ).value();
   balance = util::converter::to< koinos::contracts::token::balance_of_result >( response );

   LOG(info) << "'bob' balance: " << balance.value();

   response = koinos::chain::system_call::call( ctx, op.contract_id(), token_entry::total_supply, "" ).value();
   supply = util::converter::to< koinos::contracts::token::total_supply_result >( response );
   LOG(info) << "KOIN supply: " << supply.value();

   LOG(info) << "Transfer from 'alice' to 'bob'";
   koinos::contracts::token::transfer_arguments transfer_args;
   transfer_args.set_from( util::converter::as< std::string >( alice_address ) );
   transfer_args.set_to( util::converter::as< std::string >( bob_address ) );
   transfer_args.set_value( 25 );

   ctx.set_transaction( trx );
   try
   {
      session = ctx.make_session( 1'000'000 );
      koinos::chain::system_call::call( ctx, op.contract_id(), token_entry::transfer, util::converter::as< std::string >( transfer_args ) ).value();
      BOOST_FAIL( "Expected invalid signature exception" );
   }
   catch ( const koinos::chain::authorization_failed& ) {}

   sign_transaction( trx, bob_private_key );
   ctx.set_transaction( trx );

   try
   {
      session = ctx.make_session( 1'000'000 );
      koinos::chain::system_call::call( ctx, op.contract_id(), token_entry::transfer, util::converter::as< std::string >( transfer_args ) ).value();
      BOOST_FAIL( "Expected invalid signature exception" );
   }
   catch ( const koinos::chain::authorization_failed& ) {}

   sign_transaction( trx, alice_private_key );
   ctx.set_transaction( trx );

   session = ctx.make_session( 1'000'000 );
   response = koinos::chain::system_call::call( ctx, op.contract_id(), token_entry::transfer, util::converter::as< std::string >( transfer_args ) ).value();
   auto xfer_result = util::converter::to< koinos::contracts::token::transfer_result >( response );
   BOOST_REQUIRE( xfer_result.value() );

   balance_of_args.set_owner( util::converter::as< std::string >( alice_address ) );
   session = ctx.make_session( 1'000'000 );
   response = koinos::chain::system_call::call( ctx, op.contract_id(), token_entry::balance_of, util::converter::as< std::string >( balance_of_args ) ).value();
   balance = util::converter::to< koinos::contracts::token::balance_of_result >( response );

   LOG(info) << "'alice' balance: " << balance.value();

   balance_of_args.set_owner( util::converter::as< std::string >( bob_address ) );
   session = ctx.make_session( 1'000'000 );
   response = koinos::chain::system_call::call( ctx, op.contract_id(), token_entry::balance_of, util::converter::as< std::string >( balance_of_args ) ).value();
   balance = util::converter::to< koinos::contracts::token::balance_of_result >( response );

   LOG(info) << "'bob' balance: " << balance.value();

   session = ctx.make_session( 1'000'000 );
   response = koinos::chain::system_call::call( ctx, op.contract_id(), token_entry::total_supply, "" ).value();
   supply = util::converter::to< koinos::contracts::token::total_supply_result >( response );
   LOG(info) << "KOIN supply: " << supply.value();
}
catch( const koinos::vm_manager::vm_exception& e )
{
   LOG(info) << e.what();
   BOOST_FAIL("VM Exception");
}
KOINOS_CATCH_LOG_AND_RETHROW(info) }

BOOST_AUTO_TEST_CASE( tick_limit )
{ try {
   using namespace koinos;
   BOOST_TEST_MESSAGE( "Upload forever contract" );

   auto contract_private_key = koinos::crypto::private_key::regenerate( koinos::crypto::hash( koinos::crypto::multicodec::sha2_256, "contract"s ) );
   protocol::transaction trx;
   sign_transaction( trx, contract_private_key );
   ctx.set_transaction( trx );

   protocol::upload_contract_operation op;
   op.set_contract_id( util::converter::as< std::string >( contract_private_key.get_public_key().to_address_bytes() ) );
   op.set_bytecode( get_forever_wasm() );

   chain::system_call::apply_upload_contract_operation( ctx, op );

   auto bytecode_object = koinos::chain::system_call::get_object( ctx, koinos::chain::state::space::contract_bytecode(), op.contract_id() );
   auto meta = util::converter::to< koinos::chain::contract_metadata_object >( koinos::chain::system_call::get_object( ctx, koinos::chain::state::space::contract_metadata(), op.contract_id() ).value() );

   BOOST_REQUIRE( bytecode_object.exists() );
   BOOST_REQUIRE( bytecode_object.value().size() == op.bytecode().size() );
   BOOST_REQUIRE( std::memcmp( bytecode_object.value().c_str(), op.bytecode().c_str(), op.bytecode().size() ) == 0 );
   BOOST_REQUIRE( meta.hash() == util::converter::as< std::string >( koinos::crypto::hash( koinos::crypto::multicodec::sha2_256, bytecode_object.value() ) ) );

   koinos::protocol::call_contract_operation op2;
   op2.set_contract_id( op.contract_id() );

   BOOST_TEST_MESSAGE( "Execute forever contract inside a session" );

   auto compute_bandwidth_remaining = ctx.resource_meter().compute_bandwidth_remaining();

   auto session = ctx.make_session( 1'000'000 );
   BOOST_REQUIRE_THROW( chain::system_call::apply_call_contract_operation( ctx, op2 ), chain::insufficient_rc );
   BOOST_REQUIRE_EQUAL( session->used_rc(), 1'000'000 );
   BOOST_REQUIRE_EQUAL( session->remaining_rc(), 0 );
   session.reset();

   BOOST_REQUIRE_EQUAL( ctx.resource_meter().compute_bandwidth_remaining(), compute_bandwidth_remaining - 1'000'000 );

   // We lower the compute bandwidth block-wide so the test doesn't take long
   auto rl = chain::system_call::get_resource_limits( ctx );
   rl.set_compute_bandwidth_limit( 1'000'000 );
   ctx.resource_meter().set_resource_limit_data( rl );

   BOOST_TEST_MESSAGE( "Execute forever contract outside a session" );
   BOOST_REQUIRE_THROW( chain::system_call::apply_call_contract_operation( ctx, op2 ), chain::compute_bandwidth_limit_exceeded );

   BOOST_REQUIRE_EQUAL( ctx.resource_meter().compute_bandwidth_remaining(), 0 );

} KOINOS_CATCH_LOG_AND_RETHROW(info) }

BOOST_AUTO_TEST_CASE( transaction_reversion )
{ try {
   using namespace koinos;

   BOOST_TEST_MESSAGE( "Upload KOIN contract for testing and set balance for 'alice'" );

   auto alice_private_key = crypto::private_key::regenerate( koinos::crypto::hash( koinos::crypto::multicodec::sha2_256, "alice"s ) );
   auto alice_address = alice_private_key.get_public_key().to_address_bytes();

   auto bob_private_key = crypto::private_key::regenerate( koinos::crypto::hash( koinos::crypto::multicodec::sha2_256, "bob"s ) );
   auto bob_address = bob_private_key.get_public_key().to_address_bytes();

   auto contract_private_key = crypto::private_key::regenerate( crypto::hash( koinos::crypto::multicodec::sha2_256, "token_contract"s ) );
   auto contract_address = contract_private_key.get_public_key().to_address_bytes();

   BOOST_TEST_MESSAGE( "Test a reverted transaction" );

   // This is purposefully calling on a non-existent contract, which will result in a reversion
   protocol::call_contract_operation call_op;
   call_op.set_contract_id( contract_address );

   protocol::transaction transaction;
   chain::value_type nonce_value;
   nonce_value.set_uint64_value( 1 );
   transaction.mutable_header()->set_rc_limit( 1'000'000 );
   transaction.mutable_header()->set_nonce( util::converter::as< std::string >( nonce_value ) );
   transaction.mutable_header()->set_chain_id( chain::system_call::get_object( ctx, chain::state::space::metadata(), chain::state::key::chain_id ).value() );
   *transaction.add_operations()->mutable_call_contract() = call_op;
   set_transaction_merkle_roots( transaction, crypto::multicodec::sha2_256 );
   sign_transaction( transaction, alice_private_key );

   const auto head_state_node = db.get_head();
   auto control_state_node = db.create_writable_node( head_state_node->id(), crypto::hash( crypto::multicodec::sha2_256, "control"s ) );
   auto trx_state_node = db.create_writable_node( head_state_node->id(), crypto::hash( crypto::multicodec::sha2_256, "transaction"s ) );

   auto session = ctx.make_session( 1'000'000 );

   ctx.set_intent( chain::intent::transaction_application );

   ctx.set_state_node( trx_state_node );
   BOOST_REQUIRE_THROW( chain::system_call::apply_transaction( ctx, transaction ), chain::transaction_reverted );
   db.finalize_node( trx_state_node->id() );

   ctx.set_state_node( control_state_node );
   chain::system_call::set_account_nonce( ctx, transaction.header().payer(), transaction.header().nonce() );
   db.finalize_node( control_state_node->id() );

   BOOST_REQUIRE( trx_state_node->get_merkle_root() == control_state_node->get_merkle_root() );

   BOOST_TEST_MESSAGE( "Test proper throwing when transaction is not reverted" );

   transaction.mutable_header()->set_rc_limit( 10'000'001 );
   sign_transaction( transaction, alice_private_key );

   auto failed_trx_state_node = db.create_writable_node( head_state_node->id(), crypto::hash( crypto::multicodec::sha2_256, "failed_trx"s ) );
   ctx.set_state_node( failed_trx_state_node );

   try
   {
      chain::system_call::apply_transaction( ctx, transaction );
      BOOST_FAIL( "expected exception not thrown" );
   }
   catch ( chain::transaction_reverted& )
   {
      BOOST_FAIL( "transaction_reverted exception erroneously thrown" );
   }
   catch ( koinos::exception& e ) { /* pass */ }

   BOOST_TEST_MESSAGE( "Submitting failing transaction within a block" );

   auto parent_node = db.get_node( crypto::multihash::zero( crypto::multicodec::sha2_256 ) );
   protocol::block block;
   block.mutable_header()->set_previous( util::converter::as< std::string >( crypto::multihash::zero( crypto::multicodec::sha2_256 ) ) );
   block.mutable_header()->set_height( 1 );
   block.mutable_header()->set_timestamp( std::chrono::duration_cast< std::chrono::milliseconds >( std::chrono::system_clock::now().time_since_epoch() ).count() );
   block.mutable_header()->set_previous_state_merkle_root( util::converter::as< std::string >( parent_node->get_merkle_root() ) );
   *block.add_transactions() = transaction;
   set_block_merkle_roots( block, crypto::multicodec::sha2_256 );
   block.mutable_header()->set_signer( _signing_private_key.get_public_key().to_address_bytes() );
   block.set_id( util::converter::as< std::string >( crypto::hash( crypto::multicodec::sha2_256, block.header() ) ) );
   block.set_signature( util::converter::as< std::string >( _signing_private_key.sign_compact( util::converter::to< crypto::multihash >( block.id() ) ) ) );

   auto block_state_node = db.create_writable_node( head_state_node->id(), crypto::hash( crypto::multicodec::sha2_256, "block"s ) );
   ctx.set_state_node( block_state_node );
   ctx.set_intent( chain::intent::block_application );

   try
   {
      chain::system_call::apply_block( ctx, block );
      BOOST_FAIL( "expected exception not thrown" );
   }
   catch ( chain::transaction_reverted& )
   {
      BOOST_FAIL( "transaction_reverted exception erroneously thrown" );
   }
   catch ( koinos::exception& e )
   {
      const auto& data = e.get_json();

      BOOST_REQUIRE( data.count( "transaction_id" ) );
      BOOST_REQUIRE_EQUAL( data[ "transaction_id" ], util::to_hex( transaction.id() ) );
   }

   BOOST_TEST_MESSAGE( "Submitting reverted transactioon within a block" );

   transaction.mutable_header()->set_rc_limit( 1'000'000 );
   sign_transaction( transaction, alice_private_key );
   block.clear_transactions();
   *block.add_transactions() = transaction;
   set_block_merkle_roots( block, crypto::multicodec::sha2_256 );
   block.set_id( util::converter::as< std::string >( crypto::hash( crypto::multicodec::sha2_256, block.header() ) ) );
   block.set_signature( util::converter::as< std::string >( _signing_private_key.sign_compact( util::converter::to< crypto::multihash >( block.id() ) ) ) );

   db.discard_node( block_state_node->id() );
   block_state_node = db.create_writable_node( head_state_node->id(), crypto::hash( crypto::multicodec::sha2_256, "block"s ) );
   ctx.set_state_node( block_state_node );

   chain::system_call::apply_block( ctx, block );

} KOINOS_CATCH_LOG_AND_RETHROW(info) }

BOOST_AUTO_TEST_CASE( authorize_tests )
{
   using namespace koinos;

   auto key_a = koinos::crypto::private_key::regenerate( koinos::crypto::hash( koinos::crypto::multicodec::sha2_256, "test_key_a"s ) );
   auto key_b = koinos::crypto::private_key::regenerate( koinos::crypto::hash( koinos::crypto::multicodec::sha2_256, "test_key_b"s ) );

   // Upload KOIN contract
   auto contract_private_key = crypto::private_key::regenerate( crypto::hash( koinos::crypto::multicodec::sha2_256, "token_contract"s ) );
   auto contract_address = contract_private_key.get_public_key().to_address_bytes();
   protocol::transaction trx;
   chain::value_type nonce_value;
   nonce_value.set_uint64_value( 1 );
   trx.mutable_header()->set_nonce( util::converter::as< std::string >( nonce_value ) );
   sign_transaction( trx, contract_private_key );
   ctx.set_transaction( trx );

   koinos::protocol::upload_contract_operation upload_op;
   upload_op.set_contract_id( util::converter::as< std::string >( contract_address ) );
   upload_op.set_bytecode( get_koin_wasm() );

   koinos::chain::system_call::apply_upload_contract_operation( ctx, upload_op );

   // Mint to key_a
   koinos::contracts::token::mint_arguments mint_args;
   mint_args.set_to( util::converter::as< std::string >( key_a.get_public_key().to_address_bytes() ) );
   mint_args.set_value( 100 );

   auto session = ctx.make_session( 100'000'000 );

   auto response = koinos::chain::system_call::call( ctx, upload_op.contract_id(), token_entry::mint, util::converter::as< std::string >( mint_args ) ).value();
   auto success = util::converter::to< koinos::contracts::token::mint_result >( response );
   BOOST_REQUIRE( success.value() );

   BOOST_TEST_MESSAGE( "Override authorize call contract" );
   upload_op.set_contract_id( key_a.get_public_key().to_address_bytes() );
   upload_op.set_bytecode( get_authorize_wasm() );
   upload_op.set_authorizes_call_contract( true );

   sign_transaction( trx, key_a );
   ctx.set_transaction( trx );

   koinos::chain::system_call::apply_upload_contract_operation( ctx, upload_op );

   BOOST_TEST_MESSAGE( "Transfer from 'a' to 'b'" );
   koinos::contracts::token::transfer_arguments transfer_args;
   transfer_args.set_from( util::converter::as< std::string >( key_a.get_public_key().to_address_bytes() ) );
   transfer_args.set_to( util::converter::as< std::string >( key_b.get_public_key().to_address_bytes() ) );
   transfer_args.set_value( 25 );

   sign_transaction( trx, key_a );

   try
   {
      koinos::chain::system_call::call( ctx, util::converter::as< std::string >( contract_address ), token_entry::transfer, util::converter::as< std::string >( transfer_args ) ).value();
      BOOST_FAIL( "Expected invalid signature" );
   }
   catch ( const koinos::chain::authorization_failed& ) {}

   sign_transaction( trx, key_b );
   koinos::chain::system_call::call( ctx, util::converter::as< std::string >( contract_address ), token_entry::transfer, util::converter::as< std::string >( transfer_args ) ).value();
   BOOST_TEST_PASSPOINT();

   BOOST_TEST_MESSAGE( "Override authorize upload contract" );

   upload_op.set_authorizes_upload_contract( true );
   upload_op.set_authorizes_call_contract( false );

   sign_transaction( trx, key_a );

   koinos::chain::system_call::apply_upload_contract_operation( ctx, upload_op );

   koinos::chain::system_call::call( ctx, util::converter::as< std::string >( contract_address ), token_entry::transfer, util::converter::as< std::string >( transfer_args ) ).value();

   upload_op.set_authorizes_upload_contract( false );
   upload_op.set_authorizes_transaction_application( true );

   try
   {
      koinos::chain::system_call::apply_upload_contract_operation( ctx, upload_op );
      BOOST_FAIL( "Expected invalid signature" );
   }
   catch ( const koinos::chain::authorization_failed& ) {}

   sign_transaction( trx, key_b );
   koinos::chain::system_call::apply_upload_contract_operation( ctx, upload_op );
   BOOST_TEST_PASSPOINT();

   BOOST_TEST_MESSAGE( "Override authorize use rc" );

   ctx.set_intent( koinos::chain::intent::transaction_application );
   auto op = trx.add_operations()->mutable_call_contract();
   op->set_contract_id( util::converter::as< std::string >( contract_address ) );
   op->set_entry_point( token_entry::transfer );
   op->set_args( util::converter::as< std::string >( transfer_args ) );
   set_transaction_merkle_roots( trx, koinos::crypto::multicodec::sha2_256 );
   trx.mutable_header()->set_chain_id( koinos::chain::system_call::get_object( ctx, koinos::chain::state::space::metadata(), koinos::chain::state::key::chain_id ).value() );
   trx.mutable_header()->set_payer( key_a.get_public_key().to_address_bytes() );
   trx.mutable_header()->set_rc_limit( 10'000'000 );
   auto id_mh = crypto::hash( crypto::multicodec::sha2_256, trx.header() );
   trx.set_id( util::converter::as< std::string >( id_mh ) );
   trx.clear_signatures();
   trx.add_signatures( util::converter::as< std::string >( key_a.sign_compact( id_mh ) ) );

   try
   {
      koinos::chain::system_call::apply_transaction( ctx, trx );
      BOOST_FAIL( "Expected invalid signature" );
   }
   catch( const koinos::chain::authorization_failed& ) {}

   trx.add_signatures( util::converter::as< std::string >( key_b.sign_compact( id_mh ) ) );

   koinos::chain::system_call::apply_transaction( ctx, trx );
}

BOOST_AUTO_TEST_CASE( get_chain_id )
{
   auto chain_id = crypto::hash( koinos::crypto::multicodec::sha2_256, _genesis_data );
   auto chain_id_str = util::converter::as< std::string >( chain_id );
   BOOST_REQUIRE_EQUAL( chain_id_str, chain::system_call::get_chain_id( ctx ) );
}

BOOST_AUTO_TEST_CASE( thunk_time )
{ try {
   crypto::multihash contract_seed = crypto::hash( crypto::multicodec::sha2_256, std::string{ "contract" } );
   crypto::private_key contract_pk = crypto::private_key::regenerate( contract_seed );

/*
   #include <cstdint>
   #include <string>
   #include <koinos/system/system_calls.hpp>

   int main()
   {
      uint64_t accumulator = 0;
      for ( uint64_t i = 0; i < 10'000; i++ )
      {
          if ( i % 3 )
             accumulator += 3;
          else if ( i % 2 )
             accumulator += 2;
          else
              accumulator += 1;
      }

      std::string s = std::to_string( accumulator );
      invoke_system_call( 605, nullptr, 0, s.data(), s.size() );

      return 0;
   }
*/
   std::string contract_bytecode = util::from_hex< std::string >( "0x0061736d0100000001601060000060037f7f7f017f60037f7e7f017e60057f7f7f7f7f017f6000017f60017f017f60017f0060027f7f017f60027e7f017f60027f7f0060027f7e0060047f7f7f7e0060037f7f7f0060017e017f60047f7e7f7f017f60047f7f7f7f017f021a0103656e7612696e766f6b655f73797374656d5f63616c6c000303504f000004000000050505060605060400050501010202070707070707080706060905090905050507090905050505050705050501010a0a0b050505050505050505070c07070b0d0807040406050e0f060405017001040405030100020608017f0141c090040b071302066d656d6f72790200065f737461727400020909010041010b031113150abe86014f02000b2901017f108180808000108380808000210010858080800002402000450d00200010cf80808000000b0b080010ca808080000b02000b0e00108480808000108f808080000b040000000b4e00024020000d003f004110740f0b0240200041ffff03710d002000417f4c0d000240200041107640002200417f470d00410041303602b48c808000417f0f0b20004110740f0b108680808000000b0a0020001089808080000bc836010b7f23808080800041106b2201248080808000024041002802d08c8080000d00410010878080800041c0908480006b220241d900490d0041002103024041002802909080800022040d004100427f37029c90808000410042808084808080c000370294908080004100200141086a41707141d8aad5aa0573220436029090808000410041003602a490808000410041003602f48f8080000b410020023602fc8f808000410041c0908480003602f88f808000410041c0908480003602c88c808000410020043602dc8c8080004100417f3602d88c8080000340200341e88c8080006a200341e08c8080006a2204360200200341ec8c8080006a2004360200200341086a2203418002470d000b410041c8908480006b410f71410041c890848000410f711b220341c4908480006a200220036b41486a2204410172360200410041002802a0908080003602d48c8080004100200341c0908480006a3602d08c808000410020043602c48c8080002002418c908480006a41383602000b024002400240024002400240024002400240024002400240200041ec014b0d00024041002802b88c80800022054110200041136a4170712000410b491b22024103762204762203410371450d0020034101712004724101732202410374220641e88c8080006a280200220441086a21030240024020042802082200200641e08c8080006a2206470d0041002005417e200277713602b88c8080000c010b41002802c88c80800020004b1a200620003602082000200636020c0b200420024103742200410372360204200420006a220420042802044101723602040c0c0b200241002802c08c80800022074d0d0102402003450d0002400240200320047441022004742203410020036b72712203410020036b71417f6a22032003410c764110712203762204410576410871220020037220042000762203410276410471220472200320047622034101764102712204722003200476220341017641017122047220032004766a2200410374220641e88c8080006a28020022042802082203200641e08c8080006a2206470d0041002005417e2000777122053602b88c8080000c010b41002802c88c80800020034b1a200620033602082003200636020c0b200441086a2103200420024103723602042004200041037422006a200020026b2200360200200420026a2206200041017236020402402007450d002007410376220841037441e08c8080006a210241002802cc8c808000210402400240200541012008742208710d00410020052008723602b88c808000200221080c010b200228020821080b2008200436020c200220043602082004200236020c200420083602080b410020063602cc8c808000410020003602c08c8080000c0c0b41002802bc8c8080002209450d012009410020096b71417f6a22032003410c764110712203762204410576410871220020037220042000762203410276410471220472200320047622034101764102712204722003200476220341017641017122047220032004766a41027441e88e8080006a280200220628020441787120026b210420062100024003400240200028021022030d00200041146a2802002203450d020b200328020441787120026b22002004200020044922001b21042003200620001b2106200321000c000b0b2006280218210a0240200628020c22082006460d00024041002802c88c808000200628020822034b0d00200328020c2006471a0b200820033602082003200836020c0c0b0b0240200641146a220028020022030d0020062802102203450d03200641106a21000b03402000210b2003220841146a220028020022030d00200841106a2100200828021022030d000b200b41003602000c0a0b417f2102200041bf7f4b0d00200041136a2203417071210241002802bc8c8080002207450d004100210b024020034108762203450d00411f210b200241ffffff074b0d00200320034180fe3f6a411076410871220474220320034180e01f6a411076410471220374220020004180800f6a411076410271220074410f7620032004722000726b22034101742002200341156a7641017172411c6a210b0b410020026b21000240024002400240200b41027441e88e8080006a28020022040d0041002103410021080c010b200241004119200b4101766b200b411f461b742106410021034100210803400240200428020441787120026b220520004f0d00200521002004210820050d004100210020042108200421030c030b2003200441146a2802002205200520042006411d764104716a41106a2802002204461b200320051b21032006200441004774210620040d000b0b024020032008720d004102200b742203410020036b722007712203450d032003410020036b71417f6a22032003410c764110712203762204410576410871220620037220042006762203410276410471220472200320047622034101764102712204722003200476220341017641017122047220032004766a41027441e88e8080006a28020021030b2003450d010b0340200328020441787120026b220520004921060240200328021022040d00200341146a28020021040b2005200020061b21002003200820061b21082004210320040d000b0b2008450d00200041002802c08c80800020026b4f0d002008280218210b0240200828020c22062008460d00024041002802c88c808000200828020822034b0d00200328020c2008471a0b200620033602082003200636020c0c090b0240200841146a220428020022030d0020082802102203450d03200841106a21040b0340200421052003220641146a220428020022030d00200641106a2104200628021022030d000b200541003602000c080b024041002802c08c80800022032002490d0041002802cc8c808000210402400240200320026b22004110490d00200420026a22062000410172360204410020003602c08c808000410020063602cc8c808000200420036a2000360200200420024103723602040c010b20042003410372360204200420036a22032003280204410172360204410041003602cc8c808000410041003602c08c8080000b200441086a21030c0a0b024041002802c48c808000220620024d0d0041002802d08c808000220320026a2204200620026b2200410172360204410020003602c48c808000410020043602d08c80800020032002410372360204200341086a21030c0a0b02400240410028029090808000450d0041002802989080800021040c010b4100427f37029c90808000410042808084808080c0003702949080800041002001410c6a41707141d8aad5aa057336029090808000410041003602a490808000410041003602f48f8080004180800421040b4100210302402004200241c7006a22076a2205410020046b220b71220820024b0d00410041303602b48c8080000c0a0b024041002802f08f8080002203450d00024041002802e88f808000220420086a220020044d0d00200020034d0d010b41002103410041303602b48c8080000c0a0b41002d00f48f8080004104710d0402400240024041002802d08c8080002204450d0041f88f8080002103034002402003280200220020044b0d00200020032802046a20044b0d030b200328020822030d000b0b41001087808080002206417f460d052008210502404100280294908080002203417f6a2204200671450d00200820066b200420066a410020036b716a21050b200520024d0d05200541feffffff074b0d05024041002802f08f8080002203450d0041002802e88f808000220420056a220020044d0d06200020034b0d060b200510878080800022032006470d010c070b200520066b200b71220541feffffff074b0d0420051087808080002206200328020020032802046a460d03200621030b0240200241c8006a20054d0d002003417f460d000240200720056b41002802989080800022046a410020046b71220441feffffff074d0d00200321060c070b02402004108780808000417f460d00200420056a2105200321060c070b410020056b1087808080001a0c040b200321062003417f470d050c030b410021080c070b410021060c050b2006417f470d020b410041002802f48f8080004104723602f48f8080000b200841feffffff074b0d0120081087808080002206410010878080800022034f0d012006417f460d012003417f460d01200320066b2205200241386a4d0d010b410041002802e88f80800020056a22033602e88f8080000240200341002802ec8f8080004d0d00410020033602ec8f8080000b024002400240024041002802d08c8080002204450d0041f88f80800021030340200620032802002200200328020422086a460d02200328020822030d000c030b0b0240024041002802c88c8080002203450d00200620034f0d010b410020063602c88c8080000b41002103410020053602fc8f808000410020063602f88f8080004100417f3602d88c80800041004100280290908080003602dc8c80800041004100360284908080000340200341e88c8080006a200341e08c8080006a2204360200200341ec8c8080006a2004360200200341086a2203418002470d000b2006417820066b410f714100200641086a410f711b22036a2204200541486a220020036b2203410172360204410041002802a0908080003602d48c808000410020033602c48c808000410020043602d08c808000200620006a41383602040c020b20032d000c4108710d00200620044d0d00200020044b0d002004417820046b410f714100200441086a410f711b22006a220641002802c48c80800020056a220b20006b22004101723602042003200820056a360204410041002802a0908080003602d48c808000410020003602c48c808000410020063602d08c8080002004200b6a41383602040c010b0240200641002802c88c80800022084f0d00410020063602c88c808000200621080b200620056a210041f88f80800021030240024002400240024002400240034020032802002000460d01200328020822030d000c020b0b20032d000c410871450d010b41f88f8080002103034002402003280200220020044b0d00200020032802046a220020044b0d030b200328020821030c000b0b200320063602002003200328020420056a3602042006417820066b410f714100200641086a410f711b6a220b20024103723602042000417820006b410f714100200041086a410f711b6a2206200b6b20026b2103200b20026a2100024020042006470d00410020003602d08c808000410041002802c48c80800020036a22033602c48c808000200020034101723602040c030b024041002802cc8c8080002006470d00410020003602cc8c808000410041002802c08c80800020036a22033602c08c80800020002003410172360204200020036a20033602000c030b0240200628020422044103714101470d002004417871210702400240200441ff014b0d00200628020c21020240200628020822052004410376220941037441e08c8080006a2204460d00200820054b1a0b024020022005470d00410041002802b88c808000417e200977713602b88c8080000c020b024020022004460d00200820024b1a0b200220053602082005200236020c0c010b2006280218210902400240200628020c22052006460d0002402008200628020822044b0d00200428020c2006471a0b200520043602082004200536020c0c010b0240200641146a220428020022020d00200641106a220428020022020d00410021050c010b0340200421082002220541146a220428020022020d00200541106a2104200528021022020d000b200841003602000b2009450d0002400240200628021c220241027441e88e8080006a22042802002006470d002004200536020020050d01410041002802bc8c808000417e200277713602bc8c8080000c020b20094110411420092802102006461b6a20053602002005450d010b20052009360218024020062802102204450d0020052004360210200420053602180b20062802142204450d00200541146a2004360200200420053602180b200720036a2103200620076a21060b20062006280204417e71360204200020036a2003360200200020034101723602040240200341ff014b0d002003410376220441037441e08c8080006a21030240024041002802b88c808000220241012004742204710d00410020022004723602b88c808000200321040c010b200328020821040b2004200036020c200320003602082000200336020c200020043602080c030b41002104024020034108762202450d00411f2104200341ffffff074b0d00200220024180fe3f6a411076410871220474220220024180e01f6a411076410471220274220620064180800f6a411076410271220674410f7620022004722006726b22044101742003200441156a7641017172411c6a21040b2000200436021c20004200370210200441027441e88e8080006a2102024041002802bc8c808000220641012004742208710d0020022000360200410020062008723602bc8c80800020002002360218200020003602082000200036020c0c030b20034100411920044101766b2004411f461b742104200228020021060340200622022802044178712003460d022004411d76210620044101742104200220064104716a41106a220828020022060d000b20082000360200200020023602182000200036020c200020003602080c020b2006417820066b410f714100200641086a410f711b22036a220b200541486a220820036b2203410172360204200620086a413836020420042000413720006b410f714100200041496a410f711b6a41416a22082008200441106a491b22084123360204410041002802a0908080003602d48c808000410020033602c48c8080004100200b3602d08c808000200841106a410029028090808000370200200841002902f88f8080003702084100200841086a36028090808000410020053602fc8f808000410020063602f88f8080004100410036028490808000200841246a21030340200341073602002000200341046a22034b0d000b20082004460d0320082008280204417e713602042008200820046b2205360200200420054101723602040240200541ff014b0d002005410376220041037441e08c8080006a21030240024041002802b88c808000220641012000742200710d00410020062000723602b88c808000200321000c010b200328020821000b2000200436020c200320043602082004200336020c200420003602080c040b41002103024020054108762200450d00411f2103200541ffffff074b0d00200020004180fe3f6a411076410871220374220020004180e01f6a411076410471220074220620064180800f6a411076410271220674410f7620002003722006726b22034101742005200341156a7641017172411c6a21030b200442003702102004411c6a2003360200200341027441e88e8080006a2100024041002802bc8c808000220641012003742208710d0020002004360200410020062008723602bc8c808000200441186a2000360200200420043602082004200436020c0c040b20054100411920034101766b2003411f461b742103200028020021060340200622002802044178712005460d032003411d76210620034101742103200020064104716a41106a220828020022060d000b20082004360200200441186a20003602002004200436020c200420043602080c030b20022802082103200220003602082003200036020c20004100360218200020033602082000200236020c0b200b41086a21030c050b20002802082103200020043602082003200436020c200441186a4100360200200420033602082004200036020c0b41002802c48c808000220320024d0d0041002802d08c808000220420026a2200200320026b2203410172360204410020033602c48c808000410020003602d08c80800020042002410372360204200441086a21030c030b41002103410041303602b48c8080000c020b0240200b450d00024002402008200828021c220441027441e88e8080006a2203280200470d002003200636020020060d0141002007417e2004777122073602bc8c8080000c020b200b41104114200b2802102008461b6a20063602002006450d010b2006200b360218024020082802102203450d0020062003360210200320063602180b200841146a2802002203450d00200641146a2003360200200320063602180b024002402000410f4b0d002008200020026a2203410372360204200820036a220320032802044101723602040c010b200820026a2206200041017236020420082002410372360204200620006a20003602000240200041ff014b0d002000410376220441037441e08c8080006a21030240024041002802b88c808000220041012004742204710d00410020002004723602b88c808000200321040c010b200328020821040b2004200636020c200320063602082006200336020c200620043602080c010b02400240200041087622040d00410021030c010b411f2103200041ffffff074b0d00200420044180fe3f6a411076410871220374220420044180e01f6a411076410471220474220220024180800f6a411076410271220274410f7620042003722002726b22034101742000200341156a7641017172411c6a21030b2006200336021c20064200370210200341027441e88e8080006a21040240200741012003742202710d0020042006360200410020072002723602bc8c80800020062004360218200620063602082006200636020c0c010b20004100411920034101766b2003411f461b7421032004280200210202400340200222042802044178712000460d012003411d76210220034101742103200420024104716a41106a220528020022020d000b20052006360200200620043602182006200636020c200620063602080c010b20042802082103200420063602082003200636020c20064100360218200620033602082006200436020c0b200841086a21030c010b0240200a450d00024002402006200628021c220041027441e88e8080006a2203280200470d002003200836020020080d0141002009417e200077713602bc8c8080000c020b200a41104114200a2802102006461b6a20083602002008450d010b2008200a360218024020062802102203450d0020082003360210200320083602180b200641146a2802002203450d00200841146a2003360200200320083602180b024002402004410f4b0d002006200420026a2203410372360204200620036a220320032802044101723602040c010b200620026a2200200441017236020420062002410372360204200020046a200436020002402007450d002007410376220841037441e08c8080006a210241002802cc8c808000210302400240410120087422082005710d00410020082005723602b88c808000200221080c010b200228020821080b2008200336020c200220033602082003200236020c200320083602080b410020003602cc8c808000410020043602c08c8080000b200641086a21030b200141106a24808080800020030b0a002000108b808080000bf40e01077f02402000450d00200041786a22012000417c6a280200220241787122006a2103024020024101710d002002410371450d012001200128020022026b220141002802c88c8080002204490d01200220006a2100024041002802cc8c8080002001460d000240200241ff014b0d00200128020c21050240200128020822062002410376220741037441e08c8080006a2202460d00200420064b1a0b024020052006470d00410041002802b88c808000417e200777713602b88c8080000c030b024020052002460d00200420054b1a0b200520063602082006200536020c0c020b2001280218210702400240200128020c22052001460d0002402004200128020822024b0d00200228020c2001471a0b200520023602082002200536020c0c010b0240200141146a220228020022040d00200141106a220228020022040d00410021050c010b0340200221062004220541146a220228020022040d00200541106a2102200528021022040d000b200641003602000b2007450d0102400240200128021c220441027441e88e8080006a22022802002001470d002002200536020020050d01410041002802bc8c808000417e200477713602bc8c8080000c030b20074110411420072802102001461b6a20053602002005450d020b20052007360218024020012802102202450d0020052002360210200220053602180b20012802142202450d01200541146a2002360200200220053602180c010b200328020422024103714103470d0020032002417e71360204410020003602c08c808000200120006a2000360200200120004101723602040f0b200320014d0d0020032802042202410171450d000240024020024102710d00024041002802d08c8080002003470d00410020013602d08c808000410041002802c48c80800020006a22003602c48c80800020012000410172360204200141002802cc8c808000470d03410041003602c08c808000410041003602cc8c8080000f0b024041002802cc8c8080002003470d00410020013602cc8c808000410041002802c08c80800020006a22003602c08c80800020012000410172360204200120006a20003602000f0b200241787120006a210002400240200241ff014b0d00200328020c21040240200328020822052002410376220341037441e08c8080006a2202460d0041002802c88c80800020054b1a0b024020042005470d00410041002802b88c808000417e200377713602b88c8080000c020b024020042002460d0041002802c88c80800020044b1a0b200420053602082005200436020c0c010b2003280218210702400240200328020c22052003460d00024041002802c88c808000200328020822024b0d00200228020c2003471a0b200520023602082002200536020c0c010b0240200341146a220228020022040d00200341106a220228020022040d00410021050c010b0340200221062004220541146a220228020022040d00200541106a2102200528021022040d000b200641003602000b2007450d0002400240200328021c220441027441e88e8080006a22022802002003470d002002200536020020050d01410041002802bc8c808000417e200477713602bc8c8080000c020b20074110411420072802102003461b6a20053602002005450d010b20052007360218024020032802102202450d0020052002360210200220053602180b20032802142202450d00200541146a2002360200200220053602180b200120006a200036020020012000410172360204200141002802cc8c808000470d01410020003602c08c8080000f0b20032002417e71360204200120006a2000360200200120004101723602040b0240200041ff014b0d002000410376220241037441e08c8080006a21000240024041002802b88c808000220441012002742202710d00410020042002723602b88c808000200021020c010b200028020821020b2002200136020c200020013602082001200036020c200120023602080f0b41002102024020004108762204450d00411f2102200041ffffff074b0d00200420044180fe3f6a411076410871220274220420044180e01f6a411076410471220474220520054180800f6a411076410271220574410f7620042002722005726b22024101742000200241156a7641017172411c6a21020b200142003702102001411c6a2002360200200241027441e88e8080006a21040240024041002802bc8c808000220541012002742203710d0020042001360200410020052003723602bc8c808000200141186a2004360200200120013602082001200136020c0c010b20004100411920024101766b2002411f461b7421022004280200210502400340200522042802044178712000460d012002411d76210520024101742102200420054104716a41106a220328020022050d000b20032001360200200141186a20043602002001200136020c200120013602080c010b20042802082100200420013602082000200136020c200141186a4100360200200120003602082001200436020c0b410041002802d88c808000417f6a22013602d88c80800020010d00418090808000210103402001280200220041086a210120000d000b4100417f3602d88c8080000b0bf20101197f238080808000210141102102200120026b210320032480808080002003200036020c200328020c2104024020040d00410121052003200536020c0b0240034041002106200328020c21072007108880808000210820032008360208200821092006210a2009200a46210b4101210c200b200c71210d200d450d014100210e10c980808000210f2003200f3602042003280204211020102111200e2112201120124721134101211420132014712115024002402015450d00200328020421162016118080808000000c010b0c020b0c000b0b2003280208211741102118200320186a2119201924808080800020170f0b4901067f238080808000210141102102200120026b210320032480808080002003200036020c200328020c21042004108a8080800041102105200320056a210620062480808080000f0b080041a8908080000b830301037f0240108e808080002802002200450d000340024020002802142000280218460d002000410041002000280220118180808000001a0b02402000280204220120002802082202460d002000200120026bac41012000280224118280808000001a0b200028023422000d000b0b024041002802ac908080002200450d00024020002802142000280218460d002000410041002000280220118180808000001a0b2000280204220120002802082202460d002000200120026bac41012000280224118280808000001a0b024041002802ac908080002200450d00024020002802142000280218460d002000410041002000280220118180808000001a0b2000280204220120002802082202460d002000200120026bac41012000280224118280808000001a0b024041002802b08c8080002200450d00024020002802142000280218460d002000410041002000280220118180808000001a0b2000280204220120002802082202460d002000200120026bac41012000280224118280808000001a0b0b21000240200010cc8080800022000d0041000f0b410020003602b48c808000417f0b0d0020002802381090808080000b7101027f23808080800041106b2203248080808000417f2104024002402002417f4a0d004100411c3602b48c8080000c010b02402000200120022003410c6a10ce808080002202450d00410020023602b48c808000417f21040c010b200328020c21040b200341106a24808080800020040bc10201077f23808080800041106b22032480808080002003200236020c200320013602082003200028021822013602002003200028021420016b22013602044102210402400240200120026a22052000280238200341021092808080002206460d0020032101034002402006417f4a0d004100210620004100360218200042003703102000200028020041207236020020044102460d03200220012802046b21060c030b20012006200128020422074b22084103746a2209200928020020062007410020081b6b22076a3602002001410c410420081b6a2209200928020020076b360200200520066b22052000280238200141086a200120081b2201200420086b22041092808080002206470d000b0b2000200028022822013602182000200136021420002001200028022c6a360210200221060b200341106a24808080800020060b6401017f23808080800041106b22032480808080000240024020002001200241ff0171200341086a10cd808080002200450d00410041c6002000200041cc00461b3602b48c808000427f21010c010b200329030821010b200341106a24808080800020010b11002000280238200120021094808080000bfb01011a7f238080808000210241102103200220036b210420042480808080004190ce0021052004200036020c20042001360208200428020821062006210720052108200720084921094101210a2009200a71210b02400240200b450d00200428020c210c2004280208210d200c200d109980808000210e2004200e36020c0c010b200428020c210f200428020821104190ce002111201020116e2112200f201210998080800021132004201336020c200428020c2114200428020821154190ce002116201520167021172014201710988080800021182004201836020c0b200428020c21194110211a2004201a6a211b201b24808080800020190f0bbe0101137f238080808000210241102103200220036b21042004248080808000410a21052004200036020820042001360204200428020421062006210720052108200720084921094101210a2009200a71210b02400240200b450d002004280208210c2004280204210d200c200d109a80808000210e2004200e36020c0c010b2004280208210f20042802042110200f2010109b8080800021112004201136020c0b200428020c211241102113200420136a2114201424808080800020120f0b8801010e7f238080808000210241102103200220036b210420042480808080002004200036020c20042001360208200428020c21052004280208210641e4002107200620076e210820052008109b8080800021092004280208210a41e400210b200a200b70210c2009200c109b80808000210d4110210e2004200e6a210f200f248080808000200d0f0b9002011d7f238080808000210241102103200220036b2104200424808080800041e40021052004200036020820042001360204200428020421062006210720052108200720084921094101210a2009200a71210b02400240200b450d002004280208210c2004280204210d200c200d109780808000210e2004200e36020c0c010b41e807210f2004280204211020102111200f211220112012492113410121142013201471211502402015450d00200428020821162004280204211720162017109d8080800021182004201836020c0c010b200428020821192004280204211a2019201a109880808000211b2004201b36020c0b200428020c211c4110211d2004201d6a211e201e248080808000201c0f0b6c010d7f238080808000210241102103200220036b21042004200036020c200420013602082004280208210541182106200520067421072007200675210841302109200820096a210a200428020c210b200b200a3a0000200428020c210c4101210d200c200d6a210e200e0f0b70010d7f238080808000210241102103200220036b210441808880800021052004200036020c20042001360208200428020c2106200428020821074101210820072008742109200520096a210a200a2f0000210b2006200b3b0000200428020c210c4102210d200c200d6a210e200e0f0baf0613037f047e037f017e047f047e037f037e017f037e0e7f037e017f037e037f037e017f037e187f238080808000210241302103200220036b210420042480808080004280c2d72f21052004200037032820042001360224200429032821062006210720052108200720085421094101210a2009200a71210b02400240200b450d002004290328210c200ca7210d2004200d3602202004280224210e2004280220210f200e200f1096808080002110200420103602240c010b42808084fea6dee1112111200429032821122012211320112114201320145421154101211620152016712117024002402017450d00200429032821184280c2d72f21192018201980211a201aa7211b2004201b36021c2004290328211c4280c2d72f211d201c201d82211e201ea7211f2004201f36021820042802242120200428021c21212020202110968080800021222004202236022420042802242123200428021821244190ce002125202420256e21262023202610988080800021272004202736022420042802242128200428021821294190ce00212a2029202a70212b2028202b109880808000212c2004202c3602240c010b2004290328212d42808084fea6dee111212e202d202e80212f202fa72130200420303602142004290328213142808084fea6dee11121322031203282213320042033370328200428022421342004280214213520342035109980808000213620042036360224200429032821374280c2d72f2138203720388021392039a7213a2004203a3602102004290328213b4280c2d72f213c203b203c82213d203da7213e2004203e36020c2004280224213f200428021021404190ce002141204020416e2142203f204210988080800021432004204336022420042802242144200428021021454190ce002146204520467021472044204710988080800021482004204836022420042802242149200428020c214a4190ce00214b204a204b6e214c2049204c109880808000214d2004204d3602242004280224214e200428020c214f4190ce002150204f2050702151204e20511098808080002152200420523602240b0b2004280224215341302154200420546a2155205524808080800020530f0b8801010e7f238080808000210241102103200220036b210420042480808080002004200036020c20042001360208200428020c21052004280208210641e4002107200620076e210820052008109a8080800021092004280208210a41e400210b200a200b70210c2009200c109b80808000210d4110210e2004200e6a210f200f248080808000200d0f0b3701047f238080808000210141102102200120026b2103200324808080800041c88980800021042003200036020c2004109f80808000000b2d01037f238080808000210141102102200120026b210320032480808080002003200036020c108680808000000b4201067f238080808000210241102103200220036b21042004200036020c200420013602082004280208210520052d00002106200428020c2107200720063a00000f0b5701087f238080808000210141102102200120026b210320032480808080002003200036020c200328020c2104200410ac808080002105200510ad80808000210641102107200320076a2108200824808080800020060f0b6001087f238080808000210241102103200220036b210420042480808080002004200036020c20042001360208200428020c210520042802082106200510ac8080800021072007200636020441102108200420086a210920092480808080000f0b6001087f238080808000210241102103200220036b210420042480808080002004200036020c20042001360208200428020c210520042802082106200510ac808080002107200720063a000b41102108200420086a210920092480808080000f0b70010b7f238080808000210141102102200120026b210320032480808080002003200036020c200328020c2104200410aa808080002105200510ab808080002106200320063602082003280208210741102108200720086b21094110210a2003200a6a210b200b24808080800020090f0b8202011f7f238080808000210141102102200120026b21032003248080808000410b21042003200036020820032802082105200521062004210720062007492108410121092008200971210a02400240200a450d00410a210b2003200b36020c0c010b410b210c2003280208210d4101210e200d200e6a210f200f10ae80808000211041012111201020116b2112200320123602042003280204211320132114200c211520142015462116410121172016201771211802402018450d00200328020421194101211a2019201a6a211b2003201b3602040b2003280204211c2003201c36020c0b200328020c211d4110211e2003201e6a211f201f248080808000201d0f0b4d01077f238080808000210141102102200120026b210320032480808080002003200036020c200328020c2104200410b080808000210541102106200320066a2107200724808080800020050f0b5d01087f238080808000210241102103200220036b210420042480808080002004200036020c20042001360208200428020c2105200428020821062005200610af80808000210741102108200420086a2109200924808080800020070f0b6001087f238080808000210241102103200220036b210420042480808080002004200036020c20042001360208200428020c210520042802082106200510ac8080800021072007200636020041102108200420086a210920092480808080000f0b6f010a7f238080808000210241102103200220036b210420042480808080002004200036020c20042001360208200428020c210520042802082106418080808078210720062007722108200510ac808080002109200920083602084110210a2004200a6a210b200b2480808080000f0b4d01077f238080808000210141102102200120026b210320032480808080002003200036020c200328020c2104200410bc80808000210541102106200320066a2107200724808080800020050f0b4d01077f238080808000210141102102200120026b210320032480808080002003200036020c200328020c2104200410bb80808000210541102106200320066a2107200724808080800020050f0b4d01077f238080808000210141102102200120026b210320032480808080002003200036020c200328020c2104200410ba80808000210541102106200320066a2107200724808080800020050f0b4d01077f238080808000210141102102200120026b210320032480808080002003200036020c200328020c2104200410bf80808000210541102106200320066a2107200724808080800020050f0b3e01087f238080808000210141102102200120026b21032003200036020c200328020c2104410f2105200420056a2106417021072006200771210820080f0ba30101127f238080808000210241102103200220036b21042004248080808000417f21052004200036020c20042001360208200428020821062006210720052108200720084b21094101210a2009200a71210b0240200b450d0041d589808000210c200c109f80808000000b4101210d2004280208210e4100210f200e200f7421102010200d10c180808000211141102112200420126a2113201324808080800020110f0b4d01077f238080808000210141102102200120026b210320032480808080002003200036020c200328020c2104200410c080808000210541102106200320066a2107200724808080800020050f0b2801047f238080808000210141102102200120026b21032003200036020c200328020c210420040f0b2801047f238080808000210141102102200120026b2103200320003602042003280204210420040f0b830101087f238080808000210341202104200320046b210520052480808080002005200036021c2005200136021820052002360214200528021c210620052802182107200710b1808080001a200610b2808080001a20052802142108200810b1808080001a200610b8808080001a41202109200520096a210a200a24808080800020060f0b9601010e7f238080808000210341202104200320046b2105200524808080800041102106200520066a21072007210841082109200520096a210a200a210b2005200036021c2005200136021820052002360214200528021c210c200c2008200b10b3808080001a2005280218210d2005280214210e200c200d200e10c2808080004120210f2005200f6a21102010248080808000200c0f0b5603037f017e027f238080808000210241102103200220036b210420042480808080002004200036020c20042001370300200429030021052000200510b68080800041102106200420066a210720072480808080000f0ba401030c7f017e037f238080808000210241c0002103200220036b2104200424808080800041102105200420056a21062006210741082108200420086a21092009210a4115210b2004200036023c200420013703302004200b36022c4115210c2007200c6a210d2004290330210e200a2007200d200e10b7808080002004280208210f20002007200f10b4808080001a41c0002110200420106a211120112480808080000f0b6f03057f017e027f238080808000210441202105200420056b210620062480808080002006200136021c2006200236021820062003370310200628021c21072006280218210820062903102109200020072008200910c5808080004120210a2006200a6a210b200b2480808080000f0b4c01067f238080808000210141102102200120026b210320032480808080002003200036020420032802042104200410b9808080001a41102105200320056a2106200624808080800020040f0b2801047f238080808000210141102102200120026b21032003200036020c200328020c210420040f0b2801047f238080808000210141102102200120026b21032003200036020c200328020c210420040f0b4d01077f238080808000210141102102200120026b210320032480808080002003200036020420032802042104200410bd80808000210541102106200320066a2107200724808080800020050f0b4d01077f238080808000210141102102200120026b210320032480808080002003200036020c200328020c2104200410be80808000210541102106200320066a2107200724808080800020050f0b2501047f238080808000210141102102200120026b2103417f21042003200036020c20040f0b2801047f238080808000210141102102200120026b21032003200036020c200328020c210420040f0b2801047f238080808000210141102102200120026b21032003200036020c200328020c210420040f0b2801047f238080808000210141102102200120026b21032003200036020c200328020c210420040f0b5401077f238080808000210241102103200220036b210420042480808080002004200036020c20042001360208200428020c21052005108c80808000210641102107200420076a2108200824808080800020060f0baf0401397f238080808000210341202104200320046b210520052480808080002005200036021c2005200136021820052002360214200528021c210620052802182107200528021421082007200810c3808080002109200520093602102005280210210a200610a480808000210b200a210c200b210d200c200d4b210e4101210f200e200f71211002402010450d002006109e80808000000b410b2111200528021021122012211320112114201320144921154101211620152016712117024002402017450d00200528021021182006201810a380808000200610a18080800021192005201936020c0c010b2005280210211a201a10a580808000211b2005201b360208200610a680808000211c2005280208211d4101211e201d201e6a211f201c201f10a78080800021202005202036020c200528020c21212006202110a8808080002005280208212241012123202220236a21242006202410a980808000200528021021252006202510a2808080000b02400340200528021821262005280214212720262128202721292028202947212a4101212b202a202b71212c202c450d01200528020c212d2005280218212e202d202e10a0808080002005280218212f41012130202f20306a213120052031360218200528020c213241012133203220336a21342005203436020c0c000b0b41072135200520356a21362036213741002138200528020c2139200520383a00072039203710a0808080004120213a2005203a6a213b203b2480808080000f0b5d01087f238080808000210241102103200220036b210420042480808080002004200036020c20042001360208200428020c2105200428020821062005200610c480808000210741102108200420086a2109200924808080800020070f0b3d01067f238080808000210241102103200220036b210420042000360204200420013602002004280200210520042802042106200520066b210720070f0b9c02050d7f017e087f017e067f238080808000210441202105200420056b21062006248080808000411421072006200136021420062002360210200620033703082006280210210820062802142109200820096b210a2006200a3602042006280204210b2007210c200b210d200c200d4c210e4101210f200e200f71211002400240024020100d0020062903082111201110c6808080002112200628020421132012211420132115201420154c211641012117201620177121182018450d010b410021192006290308211a2006280214211b201a201b10c780808000211c2000201c360200200020193602040c010b413d211d2006280210211e2000201e3602002000201d3602040b4120211f2006201f6a212020202480808080000f0bd50107057f047e077f017e047f037e067f238080808000210141102102200120026b210341a08a808000210441c00021052003200037030820032903082106420121072006200784210820087921092009a7210a2005200a6b210b41d109210c200b200c6c210d410c210e200d200e75210f2003200f3602042003280204211020032903082111200328020421124103211320122013742114200420146a2115201529030021162011211720162118201720185421194101211a2019201a71211b2010201b6b211c4101211d201c201d6a211e201e0f0b6103037f017e047f238080808000210241102103200220036b210420042480808080002004200037030820042001360204200429030821052004280204210620052006109c80808000210741102108200420086a2109200924808080800020070f0b3601057f238080808000210241102103200220036b21042004200036020c20042001360208200428020c21052005280200210620060f0b1f01037f41b8908080002100410221012000200110c880808000210220020f0bb10103017f027e027f23808080800041106b22002480808080004200210142002102034020014203420142022002420183501b2002a741ffff03714103701b7c2101200242017c22024290ce00520d000b2000200110b58080800041dd04410041002000280200200020002d000b220341187441187541004822041b2000280204200320041b1080808080001a024020002c000b41004e0d002000280200108d808080000b200041106a24808080800041000b3b01017f23808080800041106b2201248080808000200141083a000e200120004100473a000f4111410041002001410e6a41021080808080001a000b040041020b040041020b040041020b0b00200010cb80808000000b0bc20402004180080bc003303030313032303330343035303630373038303931303131313231333134313531363137313831393230323132323233323432353236323732383239333033313332333333343335333633373338333934303431343234333434343534363437343834393530353135323533353435353536353735383539363036313632363336343635363636373638363937303731373237333734373537363737373837393830383138323833383438353836383738383839393039313932393339343935393639373938393962617369635f737472696e6700616c6c6f6361746f723c543e3a3a616c6c6f636174652873697a655f74206e2920276e272065786365656473206d6178696d756d20737570706f727465642073697a65000000000000000000000000000000000a000000000000006400000000000000e8030000000000001027000000000000a08601000000000040420f0000000000809698000000000000e1f5050000000000ca9a3b0000000000e40b540200000000e87648170000000010a5d4e800000000a0724e1809000000407a10f35a00000080c6a47e8d03000000c16ff286230000008a5d78456301000064a7b3b6e00d0000e8890423c78a0041c00b0b7405000000000000000000000001000000000000000000000000000000000000000200000003000000380800000000000000000000000000000200000000000000ffffffff0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c0050000" );

   protocol::upload_contract_operation op;
   op.set_bytecode( contract_bytecode );
   op.set_contract_id( contract_pk.get_public_key().to_address_bytes() );

   crypto::multihash empty_contract_seed = crypto::hash( crypto::multicodec::sha2_256, std::string{ "empty_contract" } );
   crypto::private_key empty_contract_pk = crypto::private_key::regenerate( empty_contract_seed );

/*
#include <cstdint>
#include <string>
#include <koinos/system/system_calls.hpp>

int main()
{
   return 0;
}
*/
   std::string empty_contract_bytecode = util::from_hex< std::string >( "0x0061736d0100000001150460057f7f7f7f7f017f6000006000017f60017f00021a0103656e7612696e766f6b655f73797374656d5f63616c6c000003090801010201010203030405017001010105030100020608017f01418088040b071302066d656d6f72790200065f737461727400020a96010802000b2901017f108180808000108380808000210010858080800002402000450d002000108880808000000b0b08001086808080000b02000b0e001084808080001084808080000b040041000b3b01017f23808080800041106b2201248080808000200141083a000e200120004100473a000f4111410041002001410e6a41021080808080001a000b0b002000108780808000000b" );

   protocol::upload_contract_operation empty_contract_op;
   empty_contract_op.set_bytecode( empty_contract_bytecode );
   empty_contract_op.set_contract_id( empty_contract_pk.get_public_key().to_address_bytes() );

   protocol::transaction trx;
   sign_transaction( trx, contract_pk );
   auto trx_id = crypto::hash( crypto::multicodec::sha2_256, trx.header() );
   trx.add_signatures( util::converter::as< std::string >( empty_contract_pk.sign_compact( trx_id ) ) );
   trx.add_signatures( util::converter::as< std::string >( _signing_private_key.sign_compact( trx_id ) ) );
   ctx.set_transaction( trx );


   protocol::block b;
   b.mutable_header()->set_height( 10 );
   auto id_mh = crypto::hash( crypto::multicodec::sha2_256, b.header() );
   b.set_id( util::converter::as< std::string >( id_mh ) );
   b.set_signature( util::converter::as< std::string >( contract_pk.sign_compact( id_mh ) ) );
   ctx.set_block( b );

   chain::system_call::apply_upload_contract_operation( ctx, op );

   chain::system_call::apply_upload_contract_operation( ctx, empty_contract_op );

   protocol::set_system_contract_operation ssconp;
   ssconp.set_contract_id( empty_contract_pk.get_public_key().to_address_bytes() );
   ssconp.set_system_contract( true );

   chain::system_call::apply_set_system_contract_operation( ctx, ssconp );

   LOG(info) << "benchmark contract key: " << util::to_base58( contract_pk.get_public_key().to_address_bytes() );
   LOG(info) << "empty contract key: " << util::to_base58( empty_contract_pk.get_public_key().to_address_bytes() );

   const uint64_t global_run = 100;
   std::vector< double > benchmarks;

   LOG(info) << "Calibrating compute from smart contract benchmark...";

   for ( uint64_t i = 0; i < global_run; i++ )
   {
      try
      {
         ctx.resource_meter().set_resource_limit_data( chain::system_call::get_resource_limits( ctx ) );
         auto session = ctx.make_session( 1'000'000 );

         uint64_t compute_bandwidth_start = ctx.resource_meter().compute_bandwidth_used();
         uint64_t network_bandwidth_start = ctx.resource_meter().network_bandwidth_used();
         uint64_t disk_storage_start      = ctx.resource_meter().disk_storage_used();

         chain::host_api hapi( ctx );
         auto hash = util::converter::as< std::string >( crypto::multihash::empty( crypto::multicodec::sha2_256 ) );

         auto start = std::chrono::high_resolution_clock::now();
         try
         {
            ctx.get_backend()->run( hapi, contract_bytecode, hash );
         }
         catch ( chain::exit_success& ) {}
         auto stop = std::chrono::high_resolution_clock::now();

         uint64_t compute_bandwidth_stop = ctx.resource_meter().compute_bandwidth_used();
         uint64_t network_bandwidth_stop = ctx.resource_meter().network_bandwidth_used();
         uint64_t disk_storage_stop      = ctx.resource_meter().disk_storage_used();

         uint64_t compute_used = compute_bandwidth_stop - compute_bandwidth_start;
         uint64_t network_used = network_bandwidth_stop - network_bandwidth_start;
         uint64_t disk_used = disk_storage_stop - disk_storage_start;

         auto duration = std::chrono::duration_cast< std::chrono::nanoseconds >( stop - start );
         //LOG(info) << "benchmark contract took: " << duration.count() << "us";
         //LOG(info) << " -> compute: " << compute_used;
         //LOG(info) << " -> network: " << network_used;
         //LOG(info) << " -> disk: " << disk_used;
         benchmarks.push_back( compute_used / double( duration.count() ) );
         //LOG(info) << " -> approximate nanoseconds per compute: " << compute_used / double( duration.count() );
      }
      catch ( const koinos::exception& e )
      {
         LOG(error) << "Error: " << e.what();
      }
   }

   auto mean = []( const std::vector< double >& v ) -> double {
      double sum = 0;
      for ( const auto& e : v )
         sum += e;

      return sum / v.size();
   };

   auto median = []( std::vector< double > v ) -> double {
      std::sort( v.begin(), v.end() );
      if ( v.size() % 2 == 0 )
         return ( v[ v.size() / 2 - 1 ] + v[ v.size() / 2 ] ) / 2;
      return v[ v.size() / 2 ];
   };

   auto mode = []( std::vector< double > v ) -> double {
      std::sort( v.begin(), v.end() );

      double max_count = 1, res = v[ 0 ], count = 1;
      for ( int i = 1; i < v.size(); i++ )
      {
         if ( v[i] == v[ i - 1 ] )
         {
            count++;
         }
         else {
            if ( count > max_count )
            {
               max_count = count;
               res = v[i - 1];
            }
            count = 1;
         }
      }

      if ( count > max_count )
      {
         max_count = count;
         res = v[ v.size() - 1 ];
      }

      return res;
   };

   LOG(info) << "mean: " << mean( benchmarks );
   LOG(info) << "median: " << median( benchmarks );
   LOG(info) << "mode: " << mode( benchmarks );
   LOG(info) << "min: " << *std::min_element( benchmarks.begin(), benchmarks.end() );
   LOG(info) << "max: " << *std::max_element( benchmarks.begin(), benchmarks.end() );

   double compute_per_nanosecond = mean( benchmarks );

   std::map< std::string, uint64_t > calls;
   auto timer = [&]( const std::string& name, std::function< void(void) > call, std::function< void(void) > pre = [](){}, std::function< void(void) > post = [](){} )
   {
      LOG(info) << "Testing " << name << "...";

      uint64_t total_time = 0;
      uint64_t runs = global_run;

      for ( uint64_t i = 0; i < runs; i++ )
      {
         try
         {
            ctx.resource_meter().set_resource_limit_data( chain::system_call::get_resource_limits( ctx ) );
            auto session = ctx.make_session( 1'000'000 );
            pre();
            uint64_t compute_bandwidth_start = ctx.resource_meter().compute_bandwidth_used();
            auto start = std::chrono::steady_clock::now();
            call();
            auto stop = std::chrono::steady_clock::now();
            uint64_t compute_bandwidth_stop = ctx.resource_meter().compute_bandwidth_used();
            post();

            uint64_t compute_used = compute_bandwidth_stop - compute_bandwidth_start;
            auto duration = std::chrono::duration_cast< std::chrono::nanoseconds >( stop - start );

            //LOG(info) << "system call: " << name << ", took: " << duration.count() << "ns, actual compute used: " << compute_used << ", proposed compute cost: " << duration.count() / compute_per_nanosecond ;
            total_time += duration.count();
         }
         catch ( const koinos::exception& e )
         {
            LOG(error) << "error: " << e.what();
            throw e;
         }
      }

      calls[ name ] = (total_time + runs - 1) / runs;
   };

   chain::object_space objs;
   objs.set_zone( std::string{ "test" } );
   objs.set_system( true );

   chain::system_call::put_object( ctx, objs, std::string{ "remove_key" }, std::string{ "stuff" } );

   protocol::set_system_call_operation sscop;
   sscop.mutable_target()->mutable_system_call_bundle()->set_contract_id( empty_contract_op.contract_id() );
   sscop.mutable_target()->mutable_system_call_bundle()->set_entry_point( 0x00 );
   sscop.set_call_id( 1000 );

   protocol::call_contract_operation cco;
   cco.set_entry_point( 0x00 );
   cco.set_contract_id( empty_contract_pk.get_public_key().to_address_bytes() );

   auto mtree = crypto::merkle_tree( crypto::multicodec::sha2_256, std::vector< protocol::transaction >{} );

   koinos::chain::value_type nonce_value;
   nonce_value.set_uint64_value( 1 );

   chain::system_call::set_account_nonce( ctx, std::string{ "0x123" }, util::converter::as< std::string >( nonce_value ) );

   protocol::transaction transaction;
   transaction.mutable_header()->set_chain_id( chain::system_call::get_object( ctx, chain::state::space::metadata(), chain::state::key::chain_id ).value() );
   transaction.mutable_header()->set_payer( _signing_private_key.get_public_key().to_address_bytes() );
   transaction.mutable_header()->set_payee( _signing_private_key.get_public_key().to_address_bytes() );
   transaction.mutable_header()->set_rc_limit( 1'000'000 );
   transaction.mutable_header()->set_nonce( util::converter::as< std::string>( nonce_value ) );
   auto operation_merkle_tree = crypto::merkle_tree( crypto::multicodec::sha2_256, std::vector< protocol::operation >{} );
   transaction.mutable_header()->set_operation_merkle_root( util::converter::as< std::string >( operation_merkle_tree.root()->hash() ) );
   trx_id = crypto::hash( crypto::multicodec::sha2_256, transaction.header() );
   transaction.set_id( util::converter::as< std::string >( trx_id ) );
   transaction.add_signatures( util::converter::as< std::string >( contract_pk.sign_compact( trx_id ) ) );
   transaction.add_signatures( util::converter::as< std::string >( empty_contract_pk.sign_compact( trx_id ) ) );
   transaction.add_signatures( util::converter::as< std::string >( _signing_private_key.sign_compact( util::converter::to< crypto::multihash >( transaction.id() ) ) ) );

   auto parent_node = db.get_node( crypto::multihash::zero( crypto::multicodec::sha2_256 ) );
   protocol::block block;
   block.mutable_header()->set_previous( util::converter::as< std::string >( crypto::multihash::zero( crypto::multicodec::sha2_256 ) ) );
   block.mutable_header()->set_height( 1 );
   block.mutable_header()->set_timestamp( std::chrono::duration_cast< std::chrono::milliseconds >( std::chrono::system_clock::now().time_since_epoch() ).count() );
   block.mutable_header()->set_previous_state_merkle_root( util::converter::as< std::string >( parent_node->get_merkle_root() ) );
   auto transaction_merkle_tree = crypto::merkle_tree( crypto::multicodec::sha2_256, std::vector< protocol::transaction >{} );
   block.mutable_header()->set_transaction_merkle_root( util::converter::as< std::string >( transaction_merkle_tree.root()->hash() ) );
   block.mutable_header()->set_signer( _signing_private_key.get_public_key().to_address_bytes() );
   block.set_id( util::converter::as< std::string >( koinos::crypto::hash( crypto::multicodec::sha2_256, block.header() ) ) );
   block.set_signature( util::converter::as< std::string >( _signing_private_key.sign_compact( util::converter::to< crypto::multihash >( block.id() ) ) ) );

   auto header_str = util::converter::as< std::string >( block.header() );
   auto nonce_str = util::converter::as< std::string >( nonce_value );

   std::string message = "test";
   const auto res = _signing_private_key.generate_random_proof( message );
   const auto& proof = res.first;
   const auto& proof_hash = util::converter::as< std::string >( res.second );
   auto serialized_public_key = util::converter::as< std::string >( _signing_private_key.get_public_key() );

   std::map< std::string, std::function< void( void ) > > system_call_map {
      { "check_system_authority", [&]() { chain::system_call::check_system_authority( ctx, chain::set_system_call ); } },
      { "recover_public_key", [&]() { chain::system_call::recover_public_key( ctx, chain::dsa::ecdsa_secp256k1, transaction.signatures( 0 ), transaction.id() ); } },
      { "check_authority", [&]() { chain::system_call::check_authority( ctx, chain::contract_call, transaction.header().payer() ); } },
      { "get_last_irreversible_block", [&]() { chain::system_call::get_last_irreversible_block( ctx ); } },
      { "hash", [&]() { chain::system_call::hash( ctx, std::underlying_type_t< crypto::multicodec >( crypto::multicodec::sha2_256 ), header_str ); } },
      { "get_caller", [&]() { chain::system_call::get_caller( ctx ); } },
      { "get_contract_id", [&]() { chain::system_call::get_contract_id( ctx ); } },
      { "get_account_nonce", [&]() { chain::system_call::get_account_nonce( ctx, transaction.header().payer() ); } },
      { "get_account_rc", [&]() { chain::system_call::get_account_rc( ctx, transaction.header().payer() ); } },
      { "consume_account_rc", [&]() { chain::system_call::consume_account_rc( ctx, transaction.header().payer(), 1 ); } },
      { "get_transaction_field", [&]() { chain::system_call::get_transaction_field( ctx, "header" ); } },
      { "get_block_field", [&]() { chain::system_call::get_block_field( ctx, "header" ); } },
      { "verify_signature", [&]() { chain::system_call::verify_signature( ctx, chain::dsa::ecdsa_secp256k1, trx.signatures( 0 ), trx.signatures( 0 ), trx.id() ); } },
      { "get_resource_limits", [&]() { chain::system_call::get_resource_limits( ctx ); } },
      { "consume_block_resources", [&]() { chain::system_call::consume_block_resources( ctx, 1, 1, 1 ); } },
      { "log", [&]() { chain::system_call::log( ctx, "message" ); } },
      { "exit", [&]() { try { chain::system_call::exit( ctx, chain::result() ); } catch ( ... ) {} } },
      { "process_block_signature", [&]() { chain::system_call::process_block_signature( ctx, block.id(), block.header(), block.signature() ); } },
      { "get_entry_point", [&]() { chain::system_call::get_entry_point( ctx ); } },
      { "get_arguments", [&] { chain::system_call::get_arguments( ctx ); } },
      { "put_object", [&]() { chain::system_call::put_object( ctx, objs, std::string{ "key" }, header_str ); } },
      { "get_object", [&]() { chain::system_call::get_object( ctx, objs, std::string{ "key" } ); } },
      { "get_next_object", [&]() { chain::system_call::get_next_object( ctx, objs, std::string{ "key" } ); } },
      { "get_prev_object", [&]() { chain::system_call::get_prev_object( ctx, objs, std::string{ "key" } ); } },
      { "call_contract", [&]() { chain::system_call::call( ctx, empty_contract_op.contract_id(), 0x00, empty_contract_op.bytecode() ); } },
      { "apply_set_system_call_operation", [&]() { chain::system_call::apply_set_system_call_operation( ctx, sscop ); } },
      { "apply_set_system_contract_operation", [&]() { chain::system_call::apply_set_system_contract_operation( ctx, ssconp ); } },
      { "apply_call_contract_operation", [&]() { chain::system_call::apply_call_contract_operation( ctx, cco ); } },
      { "get_transaction", [&]() { chain::system_call::get_transaction( ctx ); } },
      { "get_block", [&]() { chain::system_call::get_block( ctx ); } },
      { "get_head_info", [&]() { chain::system_call::get_head_info( ctx ); } },
      { "remove_object", [&]() { chain::system_call::remove_object( ctx, objs, std::string{ "remove_key" } ); } },
      { "pre_transaction_callback", [&]() { chain::system_call::pre_transaction_callback( ctx ); } },
      { "post_transaction_callback", [&]() { chain::system_call::post_transaction_callback( ctx ); } },
      { "pre_block_callback", [&]() { chain::system_call::pre_block_callback( ctx ); } },
      { "post_block_callback", [&]() { chain::system_call::post_block_callback( ctx ); } },
      { "verify_account_nonce", [&]() { chain::system_call::verify_account_nonce( ctx, std::string{ "0x123" }, nonce_str ); } },
      { "set_account_nonce", [&]() { chain::system_call::set_account_nonce( ctx, std::string{ "0x123" }, nonce_str ); } },
      { "verify_vrf_proof", [&]() { chain::system_call::verify_vrf_proof( ctx, chain::dsa::ecdsa_secp256k1, serialized_public_key, proof, proof_hash, message ); } },
      { "get_chain_id", [&]() { chain::system_call::get_chain_id( ctx ); } }
   };

   for ( const auto& [ name, call ] : system_call_map )
      timer( name, call );

   ctx.clear_block();
   ctx.clear_transaction();
   ctx.set_transaction( transaction );

   ctx.set_intent( chain::intent::transaction_application );
   timer( "apply_transaction",
      [&]()
      {
         chain::system_call::apply_transaction( ctx, transaction );
      },
      [&]()
      {
         transaction.mutable_header()->set_nonce( util::converter::as< std::string>( nonce_value ) );
         operation_merkle_tree = crypto::merkle_tree( crypto::multicodec::sha2_256, std::vector< protocol::operation >{} );
         transaction.mutable_header()->set_operation_merkle_root( util::converter::as< std::string >( operation_merkle_tree.root()->hash() ) );
         trx_id = crypto::hash( crypto::multicodec::sha2_256, transaction.header() );
         transaction.set_id( util::converter::as< std::string >( trx_id ) );
         transaction.clear_signatures();
         transaction.add_signatures( util::converter::as< std::string >( contract_pk.sign_compact( trx_id ) ) );
         transaction.add_signatures( util::converter::as< std::string >( empty_contract_pk.sign_compact( trx_id ) ) );
         transaction.add_signatures( util::converter::as< std::string >( _signing_private_key.sign_compact( util::converter::to< crypto::multihash >( transaction.id() ) ) ) );
      },
      [&]()
      {
         nonce_value.set_uint64_value( nonce_value.uint64_value() + 1 );
      }
   );

   nonce_value.set_uint64_value( 1 );

   transaction.mutable_header()->set_nonce( util::converter::as< std::string>( nonce_value ) );
   operation_merkle_tree = crypto::merkle_tree( crypto::multicodec::sha2_256, std::vector< protocol::operation >{} );
   transaction.mutable_header()->set_operation_merkle_root( util::converter::as< std::string >( operation_merkle_tree.root()->hash() ) );
   trx_id = crypto::hash( crypto::multicodec::sha2_256, transaction.header() );
   transaction.set_id( util::converter::as< std::string >( trx_id ) );
   transaction.clear_signatures();
   transaction.add_signatures( util::converter::as< std::string >( contract_pk.sign_compact( trx_id ) ) );
   transaction.add_signatures( util::converter::as< std::string >( _signing_private_key.sign_compact( util::converter::to< crypto::multihash >( transaction.id() ) ) ) );
   transaction.add_signatures( util::converter::as< std::string >( empty_contract_pk.sign_compact( trx_id ) ) );
   ctx.set_transaction( transaction );

   timer( "apply_upload_contract_operation", [&](){ chain::system_call::apply_upload_contract_operation( ctx, empty_contract_op ); } );

   ctx.resource_meter().set_resource_limit_data( chain::system_call::get_resource_limits( ctx ) );

   ctx.set_intent( chain::intent::block_application );
   timer( "apply_block", [&]() { chain::system_call::apply_block( ctx, block ); } );

   std::fstream rand_stream( "/dev/random", std::ios_base::in );

   auto create_random_payload = [&]( uint64_t payload_size ) -> std::string {
      std::string res( payload_size, 0x00 );
      rand_stream.read( const_cast< char* >( res.data() ), payload_size );
      BOOST_REQUIRE_EQUAL( payload_size, res.size() );
      return res;
   };

   auto lin_reg = []( const std::vector< uint64_t >& x_points, const std::vector< uint64_t >& y_points ) -> std::pair< double, double > {
      double x_mean = std::accumulate( std::begin( x_points ), std::end( x_points ), 0 ) / double( x_points.size() );
      double y_mean = std::accumulate( std::begin( y_points ), std::end( y_points ), 0 ) / double( y_points.size() );
      double ss_xy = 0;
      double ss_xx = 0;

      {
         std::vector< uint64_t > xy;
         for( std::size_t i = 0; i < x_points.size(); i++ )
         {
            xy.push_back( x_points[i] * y_points[i] );
         }

         ss_xy = std::accumulate( std::begin( xy ), std::end( xy ), 0 ) - ( x_points.size() * x_mean * y_mean );
      }

      {
         std::vector< uint64_t > xx;

         for( std::size_t i = 0; i < x_points.size(); i++ )
         {
            xx.push_back( x_points[i] * x_points[i] );
         }

         ss_xx = std::accumulate( std::begin( xx ), std::end( xx ), 0 ) - ( x_points.size() * x_mean * x_mean );
      }

      double b_1 = double( ss_xy ) / ss_xx;
      double b_0 = y_mean - ( b_1 * x_mean );
      return { b_0, b_1 };
   };

   auto sample_hash_algorithm = [&]( koinos::crypto::multicodec code ) -> std::pair< std::vector< uint64_t >, std::vector< uint64_t > > {
      std::vector< uint64_t > payload_sizes;
      std::vector< uint64_t > hash_times;

      chain::resource_limit_data rld;
      rld.set_compute_bandwidth_limit( 1'000'000'000 );

      ctx.resource_meter().set_resource_limit_data( rld );
      auto session = ctx.make_session( 1'000'000'000 );

      uint64_t runs = std::max( uint64_t( 1 ), global_run / 1000 );

      for ( int i = 0; i < 1024; i += 4 )
      {
         auto payload = create_random_payload( i );

         auto start = std::chrono::steady_clock::now();
         for ( int i = 0; i < runs; i++ )
         {
            koinos::chain::system_call::hash( ctx, std::underlying_type_t< koinos::crypto::multicodec >( code ), payload );
         }
         auto stop = std::chrono::steady_clock::now();

         payload_sizes.push_back( payload.size() );
         hash_times.push_back( std::chrono::duration_cast< std::chrono::nanoseconds >( stop - start ).count() / runs );
      }

      return { payload_sizes, hash_times };
   };

   {
      LOG(info) << "Testing sha1...";
      auto [payload_sizes, hash_times] = sample_hash_algorithm( koinos::crypto::multicodec::sha1 );
      auto [b_0, b_1] = lin_reg( payload_sizes, hash_times );
      calls[ "sha1_base" ] = std::max( int64_t(1), int64_t( ceil( b_0 ) ) );
      calls[ "sha1_per_byte" ] = std::max( int64_t(1), int64_t( ceil( b_1 ) ) );
   }

   {
      LOG(info) << "Testing sha2_256...";
      auto [payload_sizes, hash_times] = sample_hash_algorithm( koinos::crypto::multicodec::sha2_256 );
      auto [b_0, b_1] = lin_reg( payload_sizes, hash_times );
      calls[ "sha2_256_base" ] = std::max( int64_t(1), int64_t( ceil( b_0 ) ) );
      calls[ "sha2_256_per_byte" ] = std::max( int64_t(1), int64_t( ceil( b_1 ) ) );
   }

   {
      LOG(info) << "Testing sha2_512...";
      auto [payload_sizes, hash_times] = sample_hash_algorithm( koinos::crypto::multicodec::sha2_512 );
      auto [b_0, b_1] = lin_reg( payload_sizes, hash_times );
      calls[ "sha2_512_base" ] = std::max( int64_t(1), int64_t( ceil( b_0 ) ) );
      calls[ "sha2_512_per_byte" ] = std::max( int64_t(1), int64_t( ceil( b_1 ) ) );
   }

   {
      LOG(info) << "Testing keccak_256...";
      auto [payload_sizes, hash_times] = sample_hash_algorithm( koinos::crypto::multicodec::keccak_256 );
      auto [b_0, b_1] = lin_reg( payload_sizes, hash_times );
      calls[ "keccak_256_base" ] = std::max( int64_t(1), int64_t( ceil( b_0 ) ) );
      calls[ "keccak_256_per_byte" ] = std::max( int64_t(1), int64_t( ceil( b_1 ) ) );
   }

   {
      LOG(info) << "Testing ripemd_160...";
      auto [payload_sizes, hash_times] = sample_hash_algorithm( koinos::crypto::multicodec::ripemd_160 );
      auto [b_0, b_1] = lin_reg( payload_sizes, hash_times );
      calls[ "ripemd_160_base" ] = std::max( int64_t(1), int64_t( ceil( b_0 ) ) );
      calls[ "ripemd_160_per_byte" ] = std::max( int64_t(1), int64_t( ceil( b_1 ) ) );
   }

   {
      LOG(info) << "Testing event...";

      std::vector< uint64_t > payload_sizes;
      std::vector< uint64_t > event_times;

      auto address = _signing_private_key.get_public_key().to_address_bytes();

      std::vector< std::string > impacted;

      uint64_t runs =  std::max( uint64_t( 1 ), global_run / 50 );

      for ( int i = 0; i < 50; i++ )
      {
         chain::resource_limit_data rld;
         rld.set_compute_bandwidth_limit( 100'000'000 );

         ctx.resource_meter().set_resource_limit_data( rld );
         auto session = ctx.make_session( 100'000'000 );

         auto start = std::chrono::steady_clock::now();

         for ( int j = 0; j < runs; j++ )
         {
            koinos::chain::system_call::event( ctx, "event", address, impacted );
         }

         auto stop = std::chrono::steady_clock::now();

         payload_sizes.push_back( i );
         event_times.push_back( std::chrono::duration_cast< std::chrono::nanoseconds >( stop - start ).count() / runs );

         impacted.push_back( address );
      }

      auto [b_0, b_1] = lin_reg( payload_sizes, event_times );
      calls[ "event" ] = std::max( int64_t(1), int64_t( ceil( b_0 ) ) );
      calls[ "event_per_impacted" ] = std::max( int64_t(1), int64_t( ceil( b_1 ) ) );
   }

   {
      LOG(info) << "Testing deserialize multihash...";

      std::vector< uint64_t > number_of_hashes;
      std::vector< uint64_t > deserialize_times;

      auto address = _signing_private_key.get_public_key().to_address_bytes();

      std::vector< std::string > hashes;

      uint64_t runs = std::max( uint64_t( 1 ), global_run / 20 );

      for ( int i = 0; i < 20; i++ )
      {
         chain::resource_limit_data rld;
         rld.set_compute_bandwidth_limit( 100'000'000 );

         ctx.resource_meter().set_resource_limit_data( rld );
         auto session = ctx.make_session( 100'000'000 );

         auto start = std::chrono::steady_clock::now();
         for ( int j = 0; j < runs; j++ )
         {
            std::vector< crypto::multihash > leaves;
            leaves.resize( hashes.size() );
            std::transform( std::begin( hashes ), std::end( hashes ), std::begin( leaves ), []( const std::string& s ) { return util::converter::to< crypto::multihash >( s ); } );
         }
         auto stop = std::chrono::steady_clock::now();

         number_of_hashes.push_back( i );
         deserialize_times.push_back( std::chrono::duration_cast< std::chrono::nanoseconds >( stop - start ).count() / runs );

         hashes.push_back( util::converter::as< std::string >( crypto::hash( crypto::multicodec::sha2_256, create_random_payload( 32 ) ) ) );
      }

      auto [b_0, b_1] = lin_reg( number_of_hashes, deserialize_times );
      LOG(info) << b_0 << ", " << b_1;
      calls[ "deserialize_multihash_base" ] = std::max( int64_t(1), int64_t( ceil( b_0 ) ) );
      calls[ "deserialize_multihash_per_byte" ] = std::max( int64_t(1), int64_t( ceil( b_1 ) ) );
   }

   {
      LOG(info) << "Testing verify_merkle_root...";

      std::vector< crypto::multihash > merkle_leafs;
      std::vector< std::string > string_leafs;
      for ( std::size_t i = 0; i < 20; i++ )
      {
         merkle_leafs.push_back( crypto::hash( koinos::crypto::multicodec::sha2_256, create_random_payload( 32 ) ) );
         string_leafs.push_back( util::converter::as< std::string >( merkle_leafs.back() ) );
      }

      auto merkle_root = util::converter::as< std::string >( crypto::merkle_tree( koinos::crypto::multicodec::sha2_256, merkle_leafs ).root()->hash() );
      int64_t time = 0;
      uint64_t runs = std::max( uint64_t( 1 ), global_run / 20 );

      chain::resource_limit_data rld;
      rld.set_compute_bandwidth_limit( 10'000'000'000 );

      ctx.resource_meter().set_resource_limit_data( rld );
      auto session = ctx.make_session( 10'000'000'000 );

      auto start = std::chrono::steady_clock::now();
      for ( int i = 0; i < runs; i++ )
      {
         koinos::chain::system_call::verify_merkle_root( ctx, merkle_root, string_leafs );
      }
      auto stop = std::chrono::steady_clock::now();
      time += std::chrono::duration_cast< std::chrono::nanoseconds >( stop - start ).count();

      time /= runs;
      time -= ( string_leafs.size() + 1 ) * calls[ "deserialize_multihash_per_byte" ] + calls[ "deserialize_multihash_base" ];
      time -= 21 * ( calls[ "sha2_256_base" ] + 2 * 32 * calls[ "sha2_256_per_byte" ] );
      calls[ "verify_merkle_root" ] = std::max( int64_t(1), int64_t( ceil( time ) ) );
   }

   calls["deserialize_message_per_byte"] = 1;
   calls["object_serialization_per_byte"] = 1;

   std::map< std::string, std::vector< std::string > > subcalls;
   subcalls[ "process_block_signature" ] = { "get_object", "recover_public_key" };
   subcalls[ "apply_block" ] = { "get_resource_limits", "pre_block_callback", "verify_merkle_root", "hash", "process_block_signature", "put_object", "post_block_callback", "consume_block_resources" };
   subcalls[ "apply_transaction" ] = { "get_object", "verify_merkle_root", "get_account_rc", "pre_transaction_callback", "check_authority", "verify_account_nonce", "set_account_nonce", "post_transaction_callback", "consume_account_rc" };
   subcalls[ "apply_upload_contract_operation" ] = { "check_authority", "hash", "put_object", "put_object" };
   subcalls[ "apply_call_contract_operation" ] = { "call_contract" };
   subcalls[ "apply_set_system_call_operation" ] = { "check_system_authority", "get_object", "get_object", "put_object" };
   subcalls[ "apply_set_system_contract_operation" ] = { "check_system_authority", "get_object", "get_object", "put_object" };
   subcalls[ "call_contract" ] = { "get_object", "get_object" };
   subcalls[ "check_authority" ] = { "get_object", "recover_public_key", "recover_public_key", "recover_public_key" };
   subcalls[ "get_account_nonce" ] = { "get_object" };
   subcalls[ "verify_account_nonce" ] = { "get_account_nonce" };
   subcalls[ "set_account_nonce" ] = { "put_object" };
   subcalls[ "get_account_rc" ] = { "get_object" };
   subcalls[ "get_resource_limits" ] = { "get_object" };
   subcalls[ "check_system_authority" ] = { "get_object", "recover_public_key", "recover_public_key", "recover_public_key" };
   subcalls[ "verify_signature" ] = { "recover_public_key" };
   subcalls[ "get_chain_id" ] = { "get_object" };

   std::cout << "std::map< std::string, uint64_t > thunk_compute {" << std::endl;
   for ( const auto& [ key, value ] : calls )
   {
      auto time = value;
      auto iter = subcalls.find( key );
      if ( iter != subcalls.end() )
      {
         auto subs = iter->second;
         for ( const auto& element: subs )
         {
            auto siter = calls.find( element );
            KOINOS_ASSERT( siter != calls.end(), koinos::exception, "unable to find call timing for ${name}", ("name", element) );
            if ( siter->second > time )
               time = 1;
            else
               time -= siter->second;
         }
      }
      uint64_t compute = uint64_t( time * compute_per_nanosecond );
      compute = compute ? compute : 1;
      std::cout << "   { \"" << key << "\", " << compute << " }," << std::endl;
   }
   std::cout << "};" << std::endl;
} KOINOS_CATCH_LOG_AND_RETHROW(info) }

BOOST_AUTO_TEST_SUITE_END()
