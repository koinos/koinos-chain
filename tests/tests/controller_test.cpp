#include <boost/test/unit_test.hpp>

#include <boost/filesystem/operations.hpp>
#include <boost/filesystem/path.hpp>

#include <koinos/chain/constants.hpp>
#include <koinos/chain/controller.hpp>
#include <koinos/chain/exceptions.hpp>
#include <koinos/chain/state.hpp>
#include <koinos/chain/system_calls.hpp>
#include <koinos/crypto/multihash.hpp>
#include <koinos/crypto/elliptic.hpp>
#include <koinos/util/hex.hpp>
#include <koinos/util/base58.hpp>

#include <koinos/tests/contracts.hpp>

#include <koinos/contracts/token/token.pb.h>

#include <chrono>
#include <filesystem>
#include <sstream>

using namespace koinos;
using namespace std::string_literals;

struct controller_fixture
{
   controller_fixture() : _controller( 10'000'000 )
   {
      initialize_logging( "koinos_test", {}, "info" );

      auto seed = "test seed"s;
      _block_signing_private_key = crypto::private_key::regenerate( crypto::hash( koinos::crypto::multicodec::sha2_256, seed.c_str(), seed.size() ) );

      _state_dir = std::filesystem::temp_directory_path() / boost::filesystem::unique_path().string();
      LOG(info) << "Test temp dir: " << _state_dir.string();
      std::filesystem::create_directory( _state_dir );

      auto entry = _genesis_data.add_entries();
      entry->set_key( chain::state::key::genesis_key );
      entry->set_value( _block_signing_private_key.get_public_key().to_address_bytes() );
      *entry->mutable_space() = chain::state::space::metadata();

      koinos::chain::resource_limit_data rd;

      rd.set_disk_storage_cost( 10 );
      rd.set_disk_storage_limit( 204'800 );

      rd.set_network_bandwidth_cost( 5 );
      rd.set_network_bandwidth_limit( 1'048'576 );

      rd.set_compute_bandwidth_cost( 1 );
      rd.set_compute_bandwidth_limit( 100'000'000 );

      entry = _genesis_data.add_entries();
      entry->set_key( chain::state::key::resource_limit_data );
      entry->set_value( util::converter::as< std::string >( rd ) );
      *entry->mutable_space() = chain::state::space::metadata();

      koinos::chain::max_account_resources mar;

      mar.set_value( 10'000'000 );

      entry = _genesis_data.add_entries();
      entry->set_key( chain::state::key::max_account_resources );
      entry->set_value( util::converter::as< std::string >( mar ) );
      *entry->mutable_space() = chain::state::space::metadata();

      entry = _genesis_data.add_entries();
      entry->set_key( chain::state::key::protocol_descriptor );

      // protoc --experimental_allow_proto3_optional --descriptor_set_out=build/koinos_protocol.pb --include_imports `find koinos -name 'protocol.proto'`
      std::string protocol_descriptor = util::from_hex< std::string >( "0x0ac33b0a20676f6f676c652f70726f746f6275662f64657363726970746f722e70726f746f120f676f6f676c652e70726f746f627566224d0a1146696c6544657363726970746f7253657412380a0466696c6518012003280b32242e676f6f676c652e70726f746f6275662e46696c6544657363726970746f7250726f746f520466696c6522e4040a1346696c6544657363726970746f7250726f746f12120a046e616d6518012001280952046e616d6512180a077061636b61676518022001280952077061636b616765121e0a0a646570656e64656e6379180320032809520a646570656e64656e6379122b0a117075626c69635f646570656e64656e6379180a2003280552107075626c6963446570656e64656e637912270a0f7765616b5f646570656e64656e6379180b20032805520e7765616b446570656e64656e637912430a0c6d6573736167655f7479706518042003280b32202e676f6f676c652e70726f746f6275662e44657363726970746f7250726f746f520b6d6573736167655479706512410a09656e756d5f7479706518052003280b32242e676f6f676c652e70726f746f6275662e456e756d44657363726970746f7250726f746f5208656e756d5479706512410a077365727669636518062003280b32272e676f6f676c652e70726f746f6275662e5365727669636544657363726970746f7250726f746f52077365727669636512430a09657874656e73696f6e18072003280b32252e676f6f676c652e70726f746f6275662e4669656c6444657363726970746f7250726f746f5209657874656e73696f6e12360a076f7074696f6e7318082001280b321c2e676f6f676c652e70726f746f6275662e46696c654f7074696f6e7352076f7074696f6e7312490a10736f757263655f636f64655f696e666f18092001280b321f2e676f6f676c652e70726f746f6275662e536f75726365436f6465496e666f520e736f75726365436f6465496e666f12160a0673796e746178180c20012809520673796e74617822b9060a0f44657363726970746f7250726f746f12120a046e616d6518012001280952046e616d65123b0a056669656c6418022003280b32252e676f6f676c652e70726f746f6275662e4669656c6444657363726970746f7250726f746f52056669656c6412430a09657874656e73696f6e18062003280b32252e676f6f676c652e70726f746f6275662e4669656c6444657363726970746f7250726f746f5209657874656e73696f6e12410a0b6e65737465645f7479706518032003280b32202e676f6f676c652e70726f746f6275662e44657363726970746f7250726f746f520a6e65737465645479706512410a09656e756d5f7479706518042003280b32242e676f6f676c652e70726f746f6275662e456e756d44657363726970746f7250726f746f5208656e756d5479706512580a0f657874656e73696f6e5f72616e676518052003280b322f2e676f6f676c652e70726f746f6275662e44657363726970746f7250726f746f2e457874656e73696f6e52616e6765520e657874656e73696f6e52616e676512440a0a6f6e656f665f6465636c18082003280b32252e676f6f676c652e70726f746f6275662e4f6e656f6644657363726970746f7250726f746f52096f6e656f664465636c12390a076f7074696f6e7318072001280b321f2e676f6f676c652e70726f746f6275662e4d6573736167654f7074696f6e7352076f7074696f6e7312550a0e72657365727665645f72616e676518092003280b322e2e676f6f676c652e70726f746f6275662e44657363726970746f7250726f746f2e526573657276656452616e6765520d726573657276656452616e676512230a0d72657365727665645f6e616d65180a20032809520c72657365727665644e616d651a7a0a0e457874656e73696f6e52616e676512140a0573746172741801200128055205737461727412100a03656e641802200128055203656e6412400a076f7074696f6e7318032001280b32262e676f6f676c652e70726f746f6275662e457874656e73696f6e52616e67654f7074696f6e7352076f7074696f6e731a370a0d526573657276656452616e676512140a0573746172741801200128055205737461727412100a03656e641802200128055203656e64227c0a15457874656e73696f6e52616e67654f7074696f6e7312580a14756e696e7465727072657465645f6f7074696f6e18e7072003280b32242e676f6f676c652e70726f746f6275662e556e696e7465727072657465644f7074696f6e5213756e696e7465727072657465644f7074696f6e2a0908e80710808080800222c1060a144669656c6444657363726970746f7250726f746f12120a046e616d6518012001280952046e616d6512160a066e756d62657218032001280552066e756d62657212410a056c6162656c18042001280e322b2e676f6f676c652e70726f746f6275662e4669656c6444657363726970746f7250726f746f2e4c6162656c52056c6162656c123e0a047479706518052001280e322a2e676f6f676c652e70726f746f6275662e4669656c6444657363726970746f7250726f746f2e54797065520474797065121b0a09747970655f6e616d651806200128095208747970654e616d65121a0a08657874656e6465651802200128095208657874656e64656512230a0d64656661756c745f76616c7565180720012809520c64656661756c7456616c7565121f0a0b6f6e656f665f696e646578180920012805520a6f6e656f66496e646578121b0a096a736f6e5f6e616d65180a2001280952086a736f6e4e616d6512370a076f7074696f6e7318082001280b321d2e676f6f676c652e70726f746f6275662e4669656c644f7074696f6e7352076f7074696f6e7312270a0f70726f746f335f6f7074696f6e616c181120012808520e70726f746f334f7074696f6e616c22b6020a0454797065120f0a0b545950455f444f55424c451001120e0a0a545950455f464c4f41541002120e0a0a545950455f494e5436341003120f0a0b545950455f55494e5436341004120e0a0a545950455f494e543332100512100a0c545950455f46495845443634100612100a0c545950455f464958454433321007120d0a09545950455f424f4f4c1008120f0a0b545950455f535452494e471009120e0a0a545950455f47524f5550100a12100a0c545950455f4d455353414745100b120e0a0a545950455f4259544553100c120f0a0b545950455f55494e543332100d120d0a09545950455f454e554d100e12110a0d545950455f5346495845443332100f12110a0d545950455f53464958454436341010120f0a0b545950455f53494e5433321011120f0a0b545950455f53494e543634101222430a054c6162656c12120a0e4c4142454c5f4f5054494f4e414c100112120a0e4c4142454c5f5245515549524544100212120a0e4c4142454c5f5245504541544544100322630a144f6e656f6644657363726970746f7250726f746f12120a046e616d6518012001280952046e616d6512370a076f7074696f6e7318022001280b321d2e676f6f676c652e70726f746f6275662e4f6e656f664f7074696f6e7352076f7074696f6e7322e3020a13456e756d44657363726970746f7250726f746f12120a046e616d6518012001280952046e616d65123f0a0576616c756518022003280b32292e676f6f676c652e70726f746f6275662e456e756d56616c756544657363726970746f7250726f746f520576616c756512360a076f7074696f6e7318032001280b321c2e676f6f676c652e70726f746f6275662e456e756d4f7074696f6e7352076f7074696f6e73125d0a0e72657365727665645f72616e676518042003280b32362e676f6f676c652e70726f746f6275662e456e756d44657363726970746f7250726f746f2e456e756d526573657276656452616e6765520d726573657276656452616e676512230a0d72657365727665645f6e616d65180520032809520c72657365727665644e616d651a3b0a11456e756d526573657276656452616e676512140a0573746172741801200128055205737461727412100a03656e641802200128055203656e642283010a18456e756d56616c756544657363726970746f7250726f746f12120a046e616d6518012001280952046e616d6512160a066e756d62657218022001280552066e756d626572123b0a076f7074696f6e7318032001280b32212e676f6f676c652e70726f746f6275662e456e756d56616c75654f7074696f6e7352076f7074696f6e7322a7010a165365727669636544657363726970746f7250726f746f12120a046e616d6518012001280952046e616d65123e0a066d6574686f6418022003280b32262e676f6f676c652e70726f746f6275662e4d6574686f6444657363726970746f7250726f746f52066d6574686f6412390a076f7074696f6e7318032001280b321f2e676f6f676c652e70726f746f6275662e536572766963654f7074696f6e7352076f7074696f6e732289020a154d6574686f6444657363726970746f7250726f746f12120a046e616d6518012001280952046e616d65121d0a0a696e7075745f747970651802200128095209696e70757454797065121f0a0b6f75747075745f74797065180320012809520a6f75747075745479706512380a076f7074696f6e7318042001280b321e2e676f6f676c652e70726f746f6275662e4d6574686f644f7074696f6e7352076f7074696f6e7312300a10636c69656e745f73747265616d696e671805200128083a0566616c7365520f636c69656e7453747265616d696e6712300a107365727665725f73747265616d696e671806200128083a0566616c7365520f73657276657253747265616d696e672291090a0b46696c654f7074696f6e7312210a0c6a6176615f7061636b616765180120012809520b6a6176615061636b61676512300a146a6176615f6f757465725f636c6173736e616d6518082001280952126a6176614f75746572436c6173736e616d6512350a136a6176615f6d756c7469706c655f66696c6573180a200128083a0566616c736552116a6176614d756c7469706c6546696c657312440a1d6a6176615f67656e65726174655f657175616c735f616e645f686173681814200128084202180152196a61766147656e6572617465457175616c73416e6448617368123a0a166a6176615f737472696e675f636865636b5f75746638181b200128083a0566616c736552136a617661537472696e67436865636b5574663812530a0c6f7074696d697a655f666f7218092001280e32292e676f6f676c652e70726f746f6275662e46696c654f7074696f6e732e4f7074696d697a654d6f64653a055350454544520b6f7074696d697a65466f72121d0a0a676f5f7061636b616765180b200128095209676f5061636b61676512350a1363635f67656e657269635f73657276696365731810200128083a0566616c73655211636347656e65726963536572766963657312390a156a6176615f67656e657269635f73657276696365731811200128083a0566616c736552136a61766147656e65726963536572766963657312350a1370795f67656e657269635f73657276696365731812200128083a0566616c73655211707947656e65726963536572766963657312370a147068705f67656e657269635f7365727669636573182a200128083a0566616c7365521270687047656e65726963536572766963657312250a0a646570726563617465641817200128083a0566616c7365520a64657072656361746564122e0a1063635f656e61626c655f6172656e6173181f200128083a0474727565520e6363456e61626c654172656e6173122a0a116f626a635f636c6173735f707265666978182420012809520f6f626a63436c61737350726566697812290a106373686172705f6e616d657370616365182520012809520f6373686172704e616d65737061636512210a0c73776966745f707265666978182720012809520b737769667450726566697812280a107068705f636c6173735f707265666978182820012809520e706870436c61737350726566697812230a0d7068705f6e616d657370616365182920012809520c7068704e616d65737061636512340a167068705f6d657461646174615f6e616d657370616365182c2001280952147068704d657461646174614e616d65737061636512210a0c727562795f7061636b616765182d20012809520b727562795061636b61676512580a14756e696e7465727072657465645f6f7074696f6e18e7072003280b32242e676f6f676c652e70726f746f6275662e556e696e7465727072657465644f7074696f6e5213756e696e7465727072657465644f7074696f6e223a0a0c4f7074696d697a654d6f646512090a0553504545441001120d0a09434f44455f53495a45100212100a0c4c4954455f52554e54494d4510032a0908e8071080808080024a040826102722e3020a0e4d6573736167654f7074696f6e73123c0a176d6573736167655f7365745f776972655f666f726d61741801200128083a0566616c736552146d65737361676553657457697265466f726d6174124c0a1f6e6f5f7374616e646172645f64657363726970746f725f6163636573736f721802200128083a0566616c7365521c6e6f5374616e6461726444657363726970746f724163636573736f7212250a0a646570726563617465641803200128083a0566616c7365520a64657072656361746564121b0a096d61705f656e74727918072001280852086d6170456e74727912580a14756e696e7465727072657465645f6f7074696f6e18e7072003280b32242e676f6f676c652e70726f746f6275662e556e696e7465727072657465644f7074696f6e5213756e696e7465727072657465644f7074696f6e2a0908e8071080808080024a04080410054a04080510064a04080610074a04080810094a040809100a22e2030a0c4669656c644f7074696f6e7312410a05637479706518012001280e32232e676f6f676c652e70726f746f6275662e4669656c644f7074696f6e732e43547970653a06535452494e475205637479706512160a067061636b656418022001280852067061636b656412470a066a737479706518062001280e32242e676f6f676c652e70726f746f6275662e4669656c644f7074696f6e732e4a53547970653a094a535f4e4f524d414c52066a737479706512190a046c617a791805200128083a0566616c736552046c617a7912250a0a646570726563617465641803200128083a0566616c7365520a6465707265636174656412190a047765616b180a200128083a0566616c736552047765616b12580a14756e696e7465727072657465645f6f7074696f6e18e7072003280b32242e676f6f676c652e70726f746f6275662e556e696e7465727072657465644f7074696f6e5213756e696e7465727072657465644f7074696f6e222f0a054354797065120a0a06535452494e47100012080a04434f5244100112100a0c535452494e475f5049454345100222350a064a5354797065120d0a094a535f4e4f524d414c1000120d0a094a535f535452494e471001120d0a094a535f4e554d42455210022a0908e8071080808080024a040804100522730a0c4f6e656f664f7074696f6e7312580a14756e696e7465727072657465645f6f7074696f6e18e7072003280b32242e676f6f676c652e70726f746f6275662e556e696e7465727072657465644f7074696f6e5213756e696e7465727072657465644f7074696f6e2a0908e80710808080800222c0010a0b456e756d4f7074696f6e73121f0a0b616c6c6f775f616c696173180220012808520a616c6c6f77416c69617312250a0a646570726563617465641803200128083a0566616c7365520a6465707265636174656412580a14756e696e7465727072657465645f6f7074696f6e18e7072003280b32242e676f6f676c652e70726f746f6275662e556e696e7465727072657465644f7074696f6e5213756e696e7465727072657465644f7074696f6e2a0908e8071080808080024a0408051006229e010a10456e756d56616c75654f7074696f6e7312250a0a646570726563617465641801200128083a0566616c7365520a6465707265636174656412580a14756e696e7465727072657465645f6f7074696f6e18e7072003280b32242e676f6f676c652e70726f746f6275662e556e696e7465727072657465644f7074696f6e5213756e696e7465727072657465644f7074696f6e2a0908e807108080808002229c010a0e536572766963654f7074696f6e7312250a0a646570726563617465641821200128083a0566616c7365520a6465707265636174656412580a14756e696e7465727072657465645f6f7074696f6e18e7072003280b32242e676f6f676c652e70726f746f6275662e556e696e7465727072657465644f7074696f6e5213756e696e7465727072657465644f7074696f6e2a0908e80710808080800222e0020a0d4d6574686f644f7074696f6e7312250a0a646570726563617465641821200128083a0566616c7365520a6465707265636174656412710a116964656d706f74656e63795f6c6576656c18222001280e322f2e676f6f676c652e70726f746f6275662e4d6574686f644f7074696f6e732e4964656d706f74656e63794c6576656c3a134944454d504f54454e43595f554e4b4e4f574e52106964656d706f74656e63794c6576656c12580a14756e696e7465727072657465645f6f7074696f6e18e7072003280b32242e676f6f676c652e70726f746f6275662e556e696e7465727072657465644f7074696f6e5213756e696e7465727072657465644f7074696f6e22500a104964656d706f74656e63794c6576656c12170a134944454d504f54454e43595f554e4b4e4f574e100012130a0f4e4f5f534944455f454646454354531001120e0a0a4944454d504f54454e5410022a0908e807108080808002229a030a13556e696e7465727072657465644f7074696f6e12410a046e616d6518022003280b322d2e676f6f676c652e70726f746f6275662e556e696e7465727072657465644f7074696f6e2e4e616d655061727452046e616d6512290a106964656e7469666965725f76616c7565180320012809520f6964656e74696669657256616c7565122c0a12706f7369746976655f696e745f76616c75651804200128045210706f736974697665496e7456616c7565122c0a126e656761746976655f696e745f76616c756518052001280352106e65676174697665496e7456616c756512210a0c646f75626c655f76616c7565180620012801520b646f75626c6556616c756512210a0c737472696e675f76616c756518072001280c520b737472696e6756616c756512270a0f6167677265676174655f76616c7565180820012809520e61676772656761746556616c75651a4a0a084e616d6550617274121b0a096e616d655f7061727418012002280952086e616d655061727412210a0c69735f657874656e73696f6e180220022808520b6973457874656e73696f6e22a7020a0e536f75726365436f6465496e666f12440a086c6f636174696f6e18012003280b32282e676f6f676c652e70726f746f6275662e536f75726365436f6465496e666f2e4c6f636174696f6e52086c6f636174696f6e1ace010a084c6f636174696f6e12160a04706174681801200328054202100152047061746812160a047370616e1802200328054202100152047370616e12290a106c656164696e675f636f6d6d656e7473180320012809520f6c656164696e67436f6d6d656e7473122b0a11747261696c696e675f636f6d6d656e74731804200128095210747261696c696e67436f6d6d656e7473123a0a196c656164696e675f64657461636865645f636f6d6d656e747318062003280952176c656164696e674465746163686564436f6d6d656e747322d1010a1147656e657261746564436f6465496e666f124d0a0a616e6e6f746174696f6e18012003280b322d2e676f6f676c652e70726f746f6275662e47656e657261746564436f6465496e666f2e416e6e6f746174696f6e520a616e6e6f746174696f6e1a6d0a0a416e6e6f746174696f6e12160a047061746818012003280542021001520470617468121f0a0b736f757263655f66696c65180220012809520a736f7572636546696c6512140a05626567696e1803200128055205626567696e12100a03656e641804200128055203656e64427e0a13636f6d2e676f6f676c652e70726f746f627566421044657363726970746f7250726f746f7348015a2d676f6f676c652e676f6c616e672e6f72672f70726f746f6275662f74797065732f64657363726970746f727062f80101a20203475042aa021a476f6f676c652e50726f746f6275662e5265666c656374696f6e0ab5020a146b6f696e6f732f6f7074696f6e732e70726f746f12066b6f696e6f731a20676f6f676c652f70726f746f6275662f64657363726970746f722e70726f746f2a6d0a0a62797465735f74797065120a0a064241534536341000120a0a06424153453538100112070a034845581002120c0a08424c4f434b5f4944100312120a0e5452414e53414354494f4e5f49441004120f0a0b434f4e54524143545f49441005120b0a074144445245535310063a4c0a056274797065121d2e676f6f676c652e70726f746f6275662e4669656c644f7074696f6e7318d086032001280e32122e6b6f696e6f732e62797465735f7479706552056274797065880101422e5a2c6769746875622e636f6d2f6b6f696e6f732f6b6f696e6f732d70726f746f2d676f6c616e672f6b6f696e6f73620670726f746f330aa8190a1e6b6f696e6f732f70726f746f636f6c2f70726f746f636f6c2e70726f746f120f6b6f696e6f732e70726f746f636f6c1a146b6f696e6f732f6f7074696f6e732e70726f746f2290010a0a6576656e745f64617461121a0a0873657175656e636518012001280d520873657175656e6365121c0a06736f7572636518022001280c420480b518055206736f7572636512120a046e616d6518032001280952046e616d6512120a046461746118042001280c52046461746112200a08696d70616374656418052003280c420480b518065208696d706163746564225e0a14636f6e74726163745f63616c6c5f62756e646c6512250a0b636f6e74726163745f696418012001280c420480b51805520a636f6e74726163744964121f0a0b656e7472795f706f696e7418022001280d520a656e747279506f696e742292010a1273797374656d5f63616c6c5f746172676574121b0a087468756e6b5f696418012001280d480052077468756e6b496412550a1273797374656d5f63616c6c5f62756e646c6518022001280b32252e6b6f696e6f732e70726f746f636f6c2e636f6e74726163745f63616c6c5f62756e646c654800521073797374656d43616c6c42756e646c6542080a067461726765742294020a1975706c6f61645f636f6e74726163745f6f7065726174696f6e12250a0b636f6e74726163745f696418012001280c420480b51805520a636f6e74726163744964121a0a0862797465636f646518022001280c520862797465636f646512100a03616269180320012809520361626912380a18617574686f72697a65735f63616c6c5f636f6e74726163741804200128085216617574686f72697a657343616c6c436f6e7472616374122a0a11617574686f72697a65735f7573655f7263180520012808520f617574686f72697a65735573655263123c0a1a617574686f72697a65735f75706c6f61645f636f6e74726163741806200128085218617574686f72697a657355706c6f6164436f6e747261637422750a1763616c6c5f636f6e74726163745f6f7065726174696f6e12250a0b636f6e74726163745f696418012001280c420480b51805520a636f6e74726163744964121f0a0b656e7472795f706f696e7418022001280d520a656e747279506f696e7412120a046172677318032001280c52046172677322710a197365745f73797374656d5f63616c6c5f6f7065726174696f6e12170a0763616c6c5f696418012001280d520663616c6c4964123b0a0674617267657418022001280b32232e6b6f696e6f732e70726f746f636f6c2e73797374656d5f63616c6c5f7461726765745206746172676574226f0a1d7365745f73797374656d5f636f6e74726163745f6f7065726174696f6e12250a0b636f6e74726163745f696418012001280c420480b51805520a636f6e7472616374496412270a0f73797374656d5f636f6e7472616374180220012808520e73797374656d436f6e747261637422f1020a096f7065726174696f6e12550a0f75706c6f61645f636f6e747261637418012001280b322a2e6b6f696e6f732e70726f746f636f6c2e75706c6f61645f636f6e74726163745f6f7065726174696f6e4800520e75706c6f6164436f6e7472616374124f0a0d63616c6c5f636f6e747261637418022001280b32282e6b6f696e6f732e70726f746f636f6c2e63616c6c5f636f6e74726163745f6f7065726174696f6e4800520c63616c6c436f6e747261637412540a0f7365745f73797374656d5f63616c6c18032001280b322a2e6b6f696e6f732e70726f746f636f6c2e7365745f73797374656d5f63616c6c5f6f7065726174696f6e4800520d73657453797374656d43616c6c12600a137365745f73797374656d5f636f6e747261637418042001280b322e2e6b6f696e6f732e70726f746f636f6c2e7365745f73797374656d5f636f6e74726163745f6f7065726174696f6e4800521173657453797374656d436f6e747261637442040a026f7022d0010a127472616e73616374696f6e5f68656164657212190a08636861696e5f696418012001280c5207636861696e4964121d0a0872635f6c696d697418022001280442023001520772634c696d697412140a056e6f6e636518032001280c52056e6f6e636512320a156f7065726174696f6e5f6d65726b6c655f726f6f7418042001280c52136f7065726174696f6e4d65726b6c65526f6f74121a0a05706179657218052001280c420480b5180652057061796572121a0a05706179656518062001280c420480b518065205706179656522bc010a0b7472616e73616374696f6e12140a02696418012001280c420480b5180452026964123b0a0668656164657218022001280b32232e6b6f696e6f732e70726f746f636f6c2e7472616e73616374696f6e5f6865616465725206686561646572123a0a0a6f7065726174696f6e7318032003280b321a2e6b6f696e6f732e70726f746f636f6c2e6f7065726174696f6e520a6f7065726174696f6e73121e0a0a7369676e61747572657318042003280c520a7369676e61747572657322b2030a137472616e73616374696f6e5f7265636569707412140a02696418012001280c420480b5180452026964121a0a05706179657218022001280c420480b518065205706179657212240a0c6d61785f70617965725f726318032001280442023001520a6d617850617965725263121d0a0872635f6c696d697418042001280442023001520772634c696d6974121b0a0772635f75736564180520012804420230015206726355736564122e0a116469736b5f73746f726167655f7573656418062001280442023001520f6469736b53746f726167655573656412380a166e6574776f726b5f62616e6477696474685f757365641807200128044202300152146e6574776f726b42616e6477696474685573656412380a16636f6d707574655f62616e6477696474685f75736564180820012804420230015214636f6d7075746542616e64776964746855736564121a0a0872657665727465641809200128085208726576657274656412330a066576656e7473180a2003280b321b2e6b6f696e6f732e70726f746f636f6c2e6576656e745f6461746152066576656e747312120a046c6f6773180b2003280952046c6f677322fb010a0c626c6f636b5f68656164657212200a0870726576696f757318012001280c420480b51803520870726576696f7573121a0a0668656967687418022001280442023001520668656967687412200a0974696d657374616d7018032001280442023001520974696d657374616d70123b0a1a70726576696f75735f73746174655f6d65726b6c655f726f6f7418042001280c521770726576696f757353746174654d65726b6c65526f6f7412360a177472616e73616374696f6e5f6d65726b6c655f726f6f7418052001280c52157472616e73616374696f6e4d65726b6c65526f6f7412160a067369676e657218062001280c52067369676e657222b4010a05626c6f636b12140a02696418012001280c420480b518035202696412350a0668656164657218022001280b321d2e6b6f696e6f732e70726f746f636f6c2e626c6f636b5f686561646572520668656164657212400a0c7472616e73616374696f6e7318032003280b321c2e6b6f696e6f732e70726f746f636f6c2e7472616e73616374696f6e520c7472616e73616374696f6e73121c0a097369676e617475726518042001280c52097369676e617475726522b3030a0d626c6f636b5f7265636569707412140a02696418012001280c420480b5180352026964121a0a06686569676874180220012804420230015206686569676874122e0a116469736b5f73746f726167655f7573656418032001280442023001520f6469736b53746f726167655573656412380a166e6574776f726b5f62616e6477696474685f757365641804200128044202300152146e6574776f726b42616e6477696474685573656412380a16636f6d707574655f62616e6477696474685f75736564180520012804420230015214636f6d7075746542616e64776964746855736564122a0a1173746174655f6d65726b6c655f726f6f7418062001280c520f73746174654d65726b6c65526f6f7412330a066576656e747318072003280b321b2e6b6f696e6f732e70726f746f636f6c2e6576656e745f6461746152066576656e747312570a147472616e73616374696f6e5f726563656970747318082003280b32242e6b6f696e6f732e70726f746f636f6c2e7472616e73616374696f6e5f7265636569707452137472616e73616374696f6e526563656970747312120a046c6f677318092003280952046c6f677342375a356769746875622e636f6d2f6b6f696e6f732f6b6f696e6f732d70726f746f2d676f6c616e672f6b6f696e6f732f70726f746f636f6c620670726f746f33" );
      entry->set_value( protocol_descriptor );
      *entry->mutable_space() = chain::state::space::metadata();

      std::map< std::string, uint64_t > thunk_compute {
         { "apply_call_contract_operation", 22785 },
         { "apply_set_system_call_operation", 42105 },
         { "apply_set_system_contract_operation", 21175 },
         { "apply_upload_contract_operation", 19985 },
         { "require_system_authority", 19915 },
         { "call_contract", 17325 },
         { "consume_account_rc", 2905 },
         { "consume_block_resources", 3920 },
         { "event", 3815 },
         { "exit_contract", 3745 },
         { "get_account_nonce", 4690 },
         { "get_account_rc", 2800 },
         { "get_block", 3185 },
         { "get_block_field", 157150 },
         { "get_caller", 4410 },
         { "get_contract_arguments", 4375 },
         { "get_contract_id", 4165 },
         { "get_entry_point", 2520 },
         { "get_last_irreversible_block", 1750 },
         { "get_next_object", 26145 },
         { "get_object", 2170 },
         { "get_prev_object", 19600 },
         { "get_resource_limits", 2450 },
         { "get_transaction", 1575 },
         { "get_transaction_field", 109865 },
         { "hash", 2975 },
         { "log", 1995 },
         { "process_block_signature", 10850 },
         { "put_object", 1435 },
         { "recover_public_key", 5495 },
         { "require_authority", 6965 },
         { "set_contract_result", 875 },
         { "verify_signature", 8120 },
         { "apply_transaction", 27335 },
         { "apply_block", 19355 },
         { "verify_merkle_root", 10506 },
         { "get_head_info", 7178 },
         { "remove_object", 3108 },
         { "pre_transaction_callback", 500 },
         { "pre_block_callback", 500 },
         { "post_block_callback", 500 },
         { "post_transaction_callback", 500 },
         { "verify_account_nonce", 6000 },
         { "set_account_nonce", 3000 }
      };

      koinos::chain::compute_bandwidth_registry cbr;

      for ( const auto& [ key, value ] : thunk_compute )
      {
         auto centry = cbr.add_entries();
         centry->set_name( key );
         centry->set_compute( value );
      }

      entry = _genesis_data.add_entries();
      entry->set_key( chain::state::key::compute_bandwidth_registry );
      entry->set_value( util::converter::as< std::string >( cbr ) );
      *entry->mutable_space() = chain::state::space::metadata();

      _controller.open( _state_dir, _genesis_data, false );
   }

   virtual ~controller_fixture()
   {
      boost::log::core::get()->remove_all_sinks();
      std::filesystem::remove_all( _state_dir );
   }

   void set_block_merkle_roots( protocol::block& block, crypto::multicodec code, crypto::digest_size size = crypto::digest_size( 0 ) )
   {
      std::vector< crypto::multihash > hashes;
      hashes.reserve( block.transactions().size() * 2 );

      for ( const auto& trx : block.transactions() )
      {
         hashes.emplace_back( crypto::hash( code, trx.header(), size ) );
         hashes.emplace_back( crypto::hash( code, trx.signatures(), size ) );
      }

      auto transaction_merkle_tree = crypto::merkle_tree( code, hashes );
      block.mutable_header()->set_transaction_merkle_root( util::converter::as< std::string >( transaction_merkle_tree.root()->hash() ) );
   }

   void sign_block( protocol::block& block, crypto::private_key& block_signing_key )
   {
      auto id_mh = crypto::hash( crypto::multicodec::sha2_256, block.header() );
      block.set_signature( util::converter::as< std::string >( block_signing_key.sign_compact( id_mh ) ) );
   }

   void set_transaction_merkle_roots( protocol::transaction& transaction, crypto::multicodec code, crypto::digest_size size = crypto::digest_size( 0 ) )
   {
      std::vector< crypto::multihash > operations;
      operations.reserve( transaction.operations().size() );

      for ( const auto& op : transaction.operations() )
      {
         operations.emplace_back( crypto::hash( code, op, size ) );
      }

      auto operation_merkle_tree = crypto::merkle_tree( code, operations );
      transaction.mutable_header()->set_operation_merkle_root( util::converter::as< std::string >( operation_merkle_tree.root()->hash() ) );
   }

   void sign_transaction( protocol::transaction& transaction, crypto::private_key& transaction_signing_key )
   {
      transaction.mutable_header()->set_payer( transaction_signing_key.get_public_key().to_address_bytes() );
      auto id_mh = crypto::hash( crypto::multicodec::sha2_256, transaction.header() );
      transaction.set_id( util::converter::as< std::string >( id_mh ) );
      transaction.clear_signatures();
      transaction.add_signatures( util::converter::as< std::string >( transaction_signing_key.sign_compact( id_mh ) ) );
   }

   chain::controller      _controller;
   std::filesystem::path  _state_dir;
   crypto::private_key    _block_signing_private_key;
   chain::genesis_data    _genesis_data;
};

BOOST_FIXTURE_TEST_SUITE( controller_tests, controller_fixture )

BOOST_AUTO_TEST_CASE( submission_tests )
{ try {
   using namespace koinos;

   BOOST_TEST_MESSAGE( "Test submit transaction" );

   auto key = crypto::private_key::regenerate( crypto::hash( crypto::multicodec::sha2_256, "foobar"s ) );
   rpc::chain::submit_transaction_request trx_req;

   BOOST_TEST_MESSAGE( "Test submit block" );
   BOOST_TEST_MESSAGE( "Error when first block does not have height of 1" );

   rpc::chain::submit_block_request block_req;

   auto duration = std::chrono::system_clock::now().time_since_epoch();
   block_req.mutable_block()->mutable_header()->set_timestamp( std::chrono::duration_cast< std::chrono::milliseconds >( duration ).count() );
   block_req.mutable_block()->mutable_header()->set_height( 2 );
   block_req.mutable_block()->mutable_header()->set_previous_state_merkle_root( _controller.get_head_info().head_state_merkle_root() );
   block_req.mutable_block()->mutable_header()->set_previous( util::converter::as< std::string >( crypto::multihash::zero( crypto::multicodec::sha2_256 ) ) );

   set_block_merkle_roots( *block_req.mutable_block(), crypto::multicodec::sha2_256 );
   sign_block( *block_req.mutable_block(), _block_signing_private_key );

   block_req.mutable_block()->set_id( util::converter::as< std::string >( koinos::crypto::hash( crypto::multicodec::sha2_256, block_req.block().header() ) ) );

   BOOST_CHECK_THROW( _controller.submit_block( block_req ), chain::unexpected_height );

   BOOST_TEST_MESSAGE( "Error when signature does not match" );

   auto foo_key = koinos::crypto::private_key::regenerate( koinos::crypto::hash( crypto::multicodec::sha2_256, "foo"s ) );

   block_req.mutable_block()->mutable_header()->set_signer( util::converter::as< std::string >( foo_key.get_public_key().to_address_bytes() ) );
   block_req.mutable_block()->mutable_header()->set_height( 1 );
   block_req.mutable_block()->mutable_header()->set_previous_state_merkle_root( _controller.get_head_info().head_state_merkle_root() );
   block_req.mutable_block()->set_id( util::converter::as< std::string >( koinos::crypto::hash( crypto::multicodec::sha2_256, block_req.block().header() ) ) );

   sign_block( *block_req.mutable_block(), foo_key );

   BOOST_CHECK_THROW( _controller.submit_block( block_req ), chain::invalid_block_signature );

   BOOST_TEST_MESSAGE( "Error when previous block does not match" );

   block_req.mutable_block()->mutable_header()->set_previous( util::converter::as< std::string >( crypto::multihash::empty( crypto::multicodec::sha2_256 ) ) );

   set_block_merkle_roots( *block_req.mutable_block(), crypto::multicodec::sha2_256 );
   block_req.mutable_block()->set_id( util::converter::as< std::string >( koinos::crypto::hash( crypto::multicodec::sha2_256, block_req.block().header() ) ) );
   sign_block( *block_req.mutable_block(), _block_signing_private_key );

   BOOST_CHECK_THROW( _controller.submit_block( block_req ), chain::unknown_previous_block );

   BOOST_TEST_MESSAGE( "Error when block timestamp is too far in the future" );

   duration = ( std::chrono::system_clock::now() + std::chrono::minutes( 1 ) ).time_since_epoch();
   block_req.mutable_block()->mutable_header()->set_timestamp( std::chrono::duration_cast< std::chrono::milliseconds >( duration ).count() );
   block_req.mutable_block()->mutable_header()->set_previous( util::converter::as< std::string >( crypto::multihash::zero( crypto::multicodec::sha2_256 ) ) );
   block_req.mutable_block()->set_id( util::converter::as< std::string >( koinos::crypto::hash( crypto::multicodec::sha2_256, block_req.block().header() ) ) );

   BOOST_CHECK_THROW( _controller.submit_block( block_req ), chain::timestamp_out_of_bounds );

   duration = std::chrono::system_clock::now().time_since_epoch();
   block_req.mutable_block()->mutable_header()->set_timestamp( std::chrono::duration_cast< std::chrono::milliseconds >( duration ).count() );

   BOOST_TEST_MESSAGE( "Test successful block" );

   block_req.mutable_block()->mutable_header()->set_previous( util::converter::as< std::string >( crypto::multihash::zero( crypto::multicodec::sha2_256 ) ) );

   set_block_merkle_roots( *block_req.mutable_block(), crypto::multicodec::sha2_256 );
   block_req.mutable_block()->set_id( util::converter::as< std::string >( koinos::crypto::hash( crypto::multicodec::sha2_256, block_req.block().header() ) ) );
   sign_block( *block_req.mutable_block(), _block_signing_private_key );

   _controller.submit_block( block_req );

   BOOST_TEST_MESSAGE( "Error when block is too old" );

   block_req.mutable_block()->mutable_header()->set_previous( block_req.block().id() );
   block_req.mutable_block()->mutable_header()->set_height( 2 );
   block_req.mutable_block()->mutable_header()->set_timestamp( block_req.block().header().timestamp() - 1 );

   set_block_merkle_roots( *block_req.mutable_block(), crypto::multicodec::sha2_256 );
   block_req.mutable_block()->set_id( util::converter::as< std::string >( koinos::crypto::hash( crypto::multicodec::sha2_256, block_req.block().header() ) ) );
   sign_block( *block_req.mutable_block(), _block_signing_private_key );

   BOOST_CHECK_THROW( _controller.submit_block( block_req ), chain::timestamp_out_of_bounds );

   BOOST_TEST_MESSAGE( "Test chain ID retrieval" );

   BOOST_CHECK_EQUAL(
      util::converter::to< crypto::multihash >( _controller.get_chain_id().chain_id() ),
      koinos::crypto::hash( crypto::multicodec::sha2_256, _genesis_data )
   );

   BOOST_TEST_MESSAGE( "Test invalid transaction" );

   block_req.mutable_block()->mutable_header()->set_previous( block_req.block().id() );
   block_req.mutable_block()->mutable_header()->set_height( 2 );
   block_req.mutable_block()->mutable_header()->set_timestamp( block_req.block().header().timestamp() + 2 );

   auto trx = block_req.mutable_block()->add_transactions();
   chain::value_type nonce_value;
   nonce_value.set_uint64_value( 2 );
   trx->mutable_header()->set_rc_limit( 10'000 );
   trx->mutable_header()->set_nonce( util::converter::as< std::string>( nonce_value ) );
   set_transaction_merkle_roots( *trx, crypto::multicodec::sha2_256 );

   trx->set_id( util::converter::as< std::string >( crypto::hash( crypto::multicodec::sha2_256, trx->header() ) ) );

   set_block_merkle_roots( *block_req.mutable_block(), crypto::multicodec::sha2_256 );
   block_req.mutable_block()->set_id( util::converter::as< std::string >( koinos::crypto::hash( crypto::multicodec::sha2_256, block_req.block().header() ) ) );
   sign_block( *block_req.mutable_block(), _block_signing_private_key );

   try
   {
      _controller.submit_block( block_req );
      BOOST_REQUIRE( false );
   }
   catch ( koinos::exception& e )
   {
      const auto& j = e.get_json();
      BOOST_CHECK( j.find( "transaction_id" ) != j.end() );
      BOOST_CHECK_EQUAL( j["transaction_id"], util::to_hex( trx->id() ) );
   }

} KOINOS_CATCH_LOG_AND_RETHROW(info) }

BOOST_AUTO_TEST_CASE( block_irreversibility )
{ try {

   BOOST_TEST_MESSAGE( "Check block irreversibility" );

   rpc::chain::submit_block_request block_req;

   auto head_info_res = _controller.get_head_info();

   for ( uint64_t i = 1; i <= chain::default_irreversible_threshold; i++ )
   {
      auto duration = std::chrono::system_clock::now().time_since_epoch();
      block_req.mutable_block()->mutable_header()->set_timestamp( std::chrono::duration_cast< std::chrono::milliseconds >( duration ).count() );
      block_req.mutable_block()->mutable_header()->set_height( head_info_res.head_topology().height() + 1 );
      block_req.mutable_block()->mutable_header()->set_previous( head_info_res.head_topology().id() );
      block_req.mutable_block()->mutable_header()->set_previous_state_merkle_root( _controller.get_head_info().head_state_merkle_root() );

      set_block_merkle_roots( *block_req.mutable_block(), koinos::crypto::multicodec::sha2_256 );
      block_req.mutable_block()->set_id( util::converter::as< std::string >( crypto::hash( koinos::crypto::multicodec::sha2_256, block_req.block().header() ) ) );
      sign_block( *block_req.mutable_block(), _block_signing_private_key );

      _controller.submit_block( block_req );

      head_info_res = _controller.get_head_info();

      BOOST_REQUIRE( head_info_res.last_irreversible_block() == 0 );
   }

   for ( uint64_t i = chain::default_irreversible_threshold + 1; i <= chain::default_irreversible_threshold + 3; i++ )
   {
      auto duration = std::chrono::system_clock::now().time_since_epoch();
      block_req.mutable_block()->mutable_header()->set_timestamp( std::chrono::duration_cast< std::chrono::milliseconds >( duration ).count() );
      block_req.mutable_block()->mutable_header()->set_height( head_info_res.head_topology().height() + 1 );
      block_req.mutable_block()->mutable_header()->set_previous( head_info_res.head_topology().id() );
      block_req.mutable_block()->mutable_header()->set_previous_state_merkle_root( _controller.get_head_info().head_state_merkle_root() );

      set_block_merkle_roots( *block_req.mutable_block(), koinos::crypto::multicodec::sha2_256 );
      block_req.mutable_block()->set_id( util::converter::as< std::string >( crypto::hash( koinos::crypto::multicodec::sha2_256, block_req.block().header() ) ) );
      sign_block( *block_req.mutable_block(), _block_signing_private_key );

      _controller.submit_block( block_req );

      head_info_res = _controller.get_head_info();

      BOOST_REQUIRE( head_info_res.last_irreversible_block() == i - chain::default_irreversible_threshold );
   }

} KOINOS_CATCH_LOG_AND_RETHROW(info) }

BOOST_AUTO_TEST_CASE( fork_heads )
{ try {
   BOOST_TEST_MESSAGE( "Setting up forks and checking heads" );

   rpc::chain::submit_block_request block_req;

   uint64_t test_timestamp = 1609459200;

   auto root_head_info = _controller.get_head_info();
   rpc::chain::get_head_info_response head_info;
   head_info.CopyFrom( root_head_info );

   const std::string first_state_merkle_root = _controller.get_head_info().head_state_merkle_root();
   std::string last_state_merkle_root = first_state_merkle_root;
   for ( uint64_t i = 1; i <= chain::default_irreversible_threshold; i++ )
   {
      block_req.mutable_block()->mutable_header()->set_timestamp( test_timestamp + i );
      block_req.mutable_block()->mutable_header()->set_height( head_info.head_topology().height() + 1 );
      block_req.mutable_block()->mutable_header()->set_previous( head_info.head_topology().id() );
      block_req.mutable_block()->mutable_header()->set_previous_state_merkle_root( _controller.get_head_info().head_state_merkle_root() );

      set_block_merkle_roots( *block_req.mutable_block(), koinos::crypto::multicodec::sha2_256 );
      block_req.mutable_block()->set_id( util::converter::as< std::string >( crypto::hash( koinos::crypto::multicodec::sha2_256, block_req.block().header() ) ) );
      sign_block( *block_req.mutable_block(), _block_signing_private_key );

      auto receipt = _controller.submit_block( block_req ).receipt();
      last_state_merkle_root = receipt.state_merkle_root();

      head_info.mutable_head_topology()->set_height( head_info.head_topology().height() + 1 );
      head_info.mutable_head_topology()->set_previous( head_info.head_topology().id() );
      head_info.mutable_head_topology()->set_id( block_req.block().id() );
   }

   rpc::chain::get_head_info_response fork_head_info;
   fork_head_info.CopyFrom( head_info );
   head_info.CopyFrom( root_head_info );

   last_state_merkle_root = first_state_merkle_root;
   for ( uint64_t i = 1; i <= chain::default_irreversible_threshold; i++ )
   {
      block_req.mutable_block()->mutable_header()->set_timestamp( test_timestamp + i + chain::default_irreversible_threshold );
      block_req.mutable_block()->mutable_header()->set_height( head_info.head_topology().height() + 1 );
      block_req.mutable_block()->mutable_header()->set_previous( head_info.head_topology().id() );
      block_req.mutable_block()->mutable_header()->set_previous_state_merkle_root( last_state_merkle_root );

      set_block_merkle_roots( *block_req.mutable_block(), koinos::crypto::multicodec::sha2_256 );
      block_req.mutable_block()->set_id( util::converter::as< std::string >( crypto::hash( koinos::crypto::multicodec::sha2_256, block_req.block().header() ) ) );
      sign_block( *block_req.mutable_block(), _block_signing_private_key );

      auto receipt = _controller.submit_block( block_req ).receipt();
      last_state_merkle_root = receipt.state_merkle_root();

      head_info.mutable_head_topology()->set_height( head_info.head_topology().height() + 1 );
      head_info.mutable_head_topology()->set_previous( head_info.head_topology().id() );
      head_info.mutable_head_topology()->set_id( block_req.block().id() );

      auto fork_heads = _controller.get_fork_heads();

      BOOST_REQUIRE_EQUAL( fork_heads.fork_heads_size(), 2 );
      auto topo0 = fork_heads.fork_heads( 0 );
      auto topo1 = fork_heads.fork_heads( 1 );

      BOOST_CHECK( (    topo0.height()   == fork_head_info.head_topology().height()
                     && topo0.previous() == fork_head_info.head_topology().previous()
                     && topo0.id()       == fork_head_info.head_topology().id()
                     && topo1.height()   == head_info.head_topology().height()
                     && topo1.previous() == head_info.head_topology().previous()
                     && topo1.id()       == head_info.head_topology().id() )
                   || ( topo1.height()   == fork_head_info.head_topology().height()
                     && topo1.previous() == fork_head_info.head_topology().previous()
                     && topo1.id()       == fork_head_info.head_topology().id()
                     && topo0.height()   == head_info.head_topology().height()
                     && topo0.previous() == head_info.head_topology().previous()
                     && topo0.id()       == head_info.head_topology().id() ) );
   }

   block_req.mutable_block()->mutable_header()->set_timestamp( test_timestamp + ( 2 * chain::default_irreversible_threshold ) + 1 );
   block_req.mutable_block()->mutable_header()->set_height( head_info.head_topology().height() + 1 );
   block_req.mutable_block()->mutable_header()->set_previous( head_info.head_topology().id() );
   block_req.mutable_block()->mutable_header()->set_previous_state_merkle_root( last_state_merkle_root );

   set_block_merkle_roots( *block_req.mutable_block(), koinos::crypto::multicodec::sha2_256 );
   block_req.mutable_block()->set_id( util::converter::as< std::string >( crypto::hash( koinos::crypto::multicodec::sha2_256, block_req.block().header() ) ) );
   sign_block( *block_req.mutable_block(), _block_signing_private_key );

   _controller.submit_block( block_req );

   head_info.mutable_head_topology()->set_height( head_info.head_topology().height() + 1 );
   head_info.mutable_head_topology()->set_previous( head_info.head_topology().id() );
   head_info.mutable_head_topology()->set_id( block_req.block().id() );

   auto fork_heads = _controller.get_fork_heads();

   BOOST_REQUIRE_EQUAL( fork_heads.fork_heads_size(), 1 );
   BOOST_CHECK_EQUAL( fork_heads.fork_heads( 0 ).height(), head_info.head_topology().height() );
   BOOST_CHECK_EQUAL( fork_heads.fork_heads( 0 ).previous(), head_info.head_topology().previous() );
   BOOST_CHECK_EQUAL( fork_heads.fork_heads( 0 ).id(), head_info.head_topology().id() );


} KOINOS_CATCH_LOG_AND_RETHROW(info) }

BOOST_AUTO_TEST_CASE( read_contract_tests )
{ try {
   BOOST_TEST_MESSAGE( "Upload contracts" );

   auto key1 = koinos::crypto::private_key::regenerate( koinos::crypto::hash( koinos::crypto::multicodec::sha2_256, "foobar1"s ) );
   auto key2 = koinos::crypto::private_key::regenerate( koinos::crypto::hash( koinos::crypto::multicodec::sha2_256, "foobar2"s ) );
   auto key3 = koinos::crypto::private_key::regenerate( koinos::crypto::hash( koinos::crypto::multicodec::sha2_256, "foobar3"s ) );

   koinos::protocol::transaction trx1;
   koinos::chain::value_type nonce_value;
   nonce_value.set_uint64_value( 1 );

   auto op1 = trx1.add_operations()->mutable_upload_contract();
   op1->set_contract_id( util::converter::as< std::string >( key1.get_public_key().to_address_bytes() ) );
   op1->set_bytecode( get_hello_wasm() );
   trx1.mutable_header()->set_rc_limit( 10'000'000 );
   trx1.mutable_header()->set_chain_id( _controller.get_chain_id().chain_id() );
   trx1.mutable_header()->set_nonce( util::converter::as< std::string >( nonce_value ) );
   set_transaction_merkle_roots( trx1, koinos::crypto::multicodec::sha2_256 );
   sign_transaction( trx1, key1 );

   // Upload the return test contract
   koinos::protocol::transaction trx2;

   auto op2 = trx2.add_operations()->mutable_upload_contract();
   op2->set_contract_id( util::converter::as< std::string >( key2.get_public_key().to_address_bytes() ) );
   op2->set_bytecode( get_contract_return_wasm() );
   trx2.mutable_header()->set_rc_limit( 10'000'000 );
   trx2.mutable_header()->set_chain_id( _controller.get_chain_id().chain_id() );
   trx2.mutable_header()->set_nonce( util::converter::as< std::string >( nonce_value ) );
   set_transaction_merkle_roots( trx2, koinos::crypto::multicodec::sha2_256 );
   sign_transaction( trx2, key2 );

   // Upload the db write contract
   koinos::protocol::transaction trx3;

   auto op3 = trx3.add_operations()->mutable_upload_contract();
   op3->set_contract_id( util::converter::as< std::string >( key3.get_public_key().to_address_bytes() ) );
   op3->set_bytecode( get_db_write_wasm() );
   trx3.mutable_header()->set_rc_limit( 10'000'000 );
   trx3.mutable_header()->set_chain_id( _controller.get_chain_id().chain_id() );
   trx3.mutable_header()->set_nonce( util::converter::as< std::string >( nonce_value ) );
   set_transaction_merkle_roots( trx3, koinos::crypto::multicodec::sha2_256 );
   sign_transaction( trx3, key3 );

   koinos::rpc::chain::submit_block_request block_req;

   auto duration = std::chrono::system_clock::now().time_since_epoch();
   block_req.mutable_block()->mutable_header()->set_timestamp( std::chrono::duration_cast< std::chrono::milliseconds >( duration ).count() );
   block_req.mutable_block()->mutable_header()->set_height( 1 );
   block_req.mutable_block()->mutable_header()->set_previous( util::converter::as< std::string >( koinos::crypto::multihash::zero( koinos::crypto::multicodec::sha2_256 ) ) );
   block_req.mutable_block()->mutable_header()->set_previous_state_merkle_root( _controller.get_head_info().head_state_merkle_root() );
   *block_req.mutable_block()->add_transactions() = trx1;
   *block_req.mutable_block()->add_transactions() = trx2;
   *block_req.mutable_block()->add_transactions() = trx3;

   set_block_merkle_roots( *block_req.mutable_block(), koinos::crypto::multicodec::sha2_256 );
   block_req.mutable_block()->set_id( util::converter::as< std::string >( koinos::crypto::hash( koinos::crypto::multicodec::sha2_256, block_req.block().header() ) ) );
   sign_block( *block_req.mutable_block(), _block_signing_private_key );

   _controller.submit_block( block_req );

   BOOST_TEST_MESSAGE( "Test read contract logs" );

   koinos::rpc::chain::read_contract_request request;
   request.set_contract_id( util::converter::as< std::string >( key1.get_public_key().to_address_bytes() ) );
   request.set_entry_point( 0 );

   auto response = _controller.read_contract( request );

   BOOST_REQUIRE( response.result().size() == 0 );
   BOOST_REQUIRE( response.logs( 0 ) == "Greetings from koinos vm" );

   BOOST_TEST_MESSAGE( "Test read contract return" );

   request.set_contract_id( util::converter::as< std::string >( key2.get_public_key().to_address_bytes() ) );
   request.set_args( "echo" );

   response = _controller.read_contract( request );

   auto return_str = response.result();
   BOOST_REQUIRE( std::string( "echo" ).size() == response.result().size() );
   BOOST_REQUIRE( std::string( "echo" ) == response.result() );


   BOOST_TEST_MESSAGE( "Test read contract db write" );

   request.set_contract_id( util::converter::as< std::string >( key3.get_public_key().to_address_bytes() ) );
   BOOST_REQUIRE_THROW( _controller.read_contract( request ), koinos::chain::read_only_context );

} KOINOS_CATCH_LOG_AND_RETHROW(info) }

BOOST_AUTO_TEST_CASE( transaction_reversion_test )
{ try {
   BOOST_TEST_MESSAGE( "Upload KOIN contract and attempt to mint to Alice" );

   auto contract_private_key = koinos::crypto::private_key::regenerate( koinos::crypto::hash( koinos::crypto::multicodec::sha2_256, "contract"s ) );
   auto alice_private_key = koinos::crypto::private_key::regenerate( koinos::crypto::hash( koinos::crypto::multicodec::sha2_256, "alice"s ) );
   auto alice_address = alice_private_key.get_public_key().to_address_bytes();
   koinos::protocol::transaction trx1;
   koinos::chain::value_type nonce_value;
   nonce_value.set_uint64_value( 1 );

   // Upload the KOIN contract
   auto op1 = trx1.add_operations()->mutable_upload_contract();
   op1->set_contract_id( util::converter::as< std::string >( contract_private_key.get_public_key().to_address_bytes() ) );
   op1->set_bytecode( get_koin_wasm() );
   trx1.mutable_header()->set_rc_limit( 10'000'000 );
   trx1.mutable_header()->set_chain_id( _controller.get_chain_id().chain_id() );
   trx1.mutable_header()->set_nonce( util::converter::as< std::string >( nonce_value ) );
   set_transaction_merkle_roots( trx1, koinos::crypto::multicodec::sha2_256 );
   sign_transaction( trx1, contract_private_key );

   koinos::protocol::transaction trx2;

   koinos::contracts::token::mint_arguments mint_arg;
   mint_arg.set_to( alice_address );
   mint_arg.set_value( 100 );

   auto op2 = trx2.add_operations()->mutable_call_contract();
   op2->set_contract_id( op1->contract_id() );
   op2->set_entry_point( 0xc2f82bdc );
   op2->set_args( mint_arg.SerializeAsString() );
   trx2.mutable_header()->set_rc_limit( 10'000'000 );
   trx2.mutable_header()->set_chain_id( _controller.get_chain_id().chain_id() );
   trx2.mutable_header()->set_nonce( util::converter::as< std::string >( nonce_value ) );
   set_transaction_merkle_roots( trx2, koinos::crypto::multicodec::sha2_256 );
   sign_transaction( trx2, alice_private_key );

   koinos::rpc::chain::submit_block_request block_req;

   auto duration = std::chrono::system_clock::now().time_since_epoch();
   block_req.mutable_block()->mutable_header()->set_timestamp( std::chrono::duration_cast< std::chrono::milliseconds >( duration ).count() );
   block_req.mutable_block()->mutable_header()->set_height( 1 );
   block_req.mutable_block()->mutable_header()->set_previous( util::converter::as< std::string >( koinos::crypto::multihash::zero( koinos::crypto::multicodec::sha2_256 ) ) );
   block_req.mutable_block()->mutable_header()->set_previous_state_merkle_root( _controller.get_head_info().head_state_merkle_root() );
   *block_req.mutable_block()->add_transactions() = trx1;
   *block_req.mutable_block()->add_transactions() = trx2;

   set_block_merkle_roots( *block_req.mutable_block(), koinos::crypto::multicodec::sha2_256 );
   block_req.mutable_block()->set_id( util::converter::as< std::string >( koinos::crypto::hash( koinos::crypto::multicodec::sha2_256, block_req.block().header() ) ) );
   sign_block( *block_req.mutable_block(), _block_signing_private_key );

   _controller.submit_block( block_req );

   BOOST_TEST_MESSAGE( "Verify mint did nothing" );

   koinos::contracts::token::balance_of_arguments bal_args;
   bal_args.set_owner( alice_address );

   koinos::rpc::chain::read_contract_request request;
   request.set_contract_id( op1->contract_id() );
   request.set_entry_point( 0x15619248 );
   request.set_args( bal_args.SerializeAsString() );

   auto response = _controller.read_contract( request );
   koinos::contracts::token::balance_of_result bal_ret;
   bal_ret.ParseFromString( response.result() );

   BOOST_REQUIRE_EQUAL( bal_ret.value(), 0 );

} KOINOS_CATCH_LOG_AND_RETHROW(info) }

BOOST_AUTO_TEST_CASE( receipt_test )
{ try {
   BOOST_TEST_MESSAGE( "Submit block with KOIN contract upload and attempted mint" );

   auto rc_limit1 = 10'000'000;
   auto rc_limit2 = 9'000'000;

   auto contract_private_key = koinos::crypto::private_key::regenerate( koinos::crypto::hash( koinos::crypto::multicodec::sha2_256, "contract"s ) );
   auto alice_private_key = koinos::crypto::private_key::regenerate( koinos::crypto::hash( koinos::crypto::multicodec::sha2_256, "alice"s ) );
   auto alice_address = alice_private_key.get_public_key().to_address_bytes();
   koinos::protocol::transaction trx1;
   koinos::chain::value_type nonce_value;
   nonce_value.set_uint64_value( 1 );

   // Upload the KOIN contract
   auto op1 = trx1.add_operations()->mutable_upload_contract();
   op1->set_contract_id( util::converter::as< std::string >( contract_private_key.get_public_key().to_address_bytes() ) );
   op1->set_bytecode( get_koin_wasm() );
   trx1.mutable_header()->set_rc_limit( rc_limit1 );
   trx1.mutable_header()->set_chain_id( _controller.get_chain_id().chain_id() );
   trx1.mutable_header()->set_nonce( util::converter::as< std::string >( nonce_value ) );
   set_transaction_merkle_roots( trx1, koinos::crypto::multicodec::sha2_256 );
   sign_transaction( trx1, contract_private_key );

   koinos::protocol::transaction trx2;

   koinos::contracts::token::mint_arguments mint_arg;
   mint_arg.set_to( alice_address );
   mint_arg.set_value( 100 );

   auto op2 = trx2.add_operations()->mutable_call_contract();
   op2->set_contract_id( op1->contract_id() );
   op2->set_entry_point( 0xc2f82bdc );
   op2->set_args( mint_arg.SerializeAsString() );
   trx2.mutable_header()->set_rc_limit( rc_limit2 );
   trx2.mutable_header()->set_chain_id( _controller.get_chain_id().chain_id() );
   trx2.mutable_header()->set_nonce( util::converter::as< std::string >( nonce_value ) );
   set_transaction_merkle_roots( trx2, koinos::crypto::multicodec::sha2_256 );
   sign_transaction( trx2, alice_private_key );

   koinos::rpc::chain::submit_block_request block_req;

   auto duration = std::chrono::system_clock::now().time_since_epoch();
   block_req.mutable_block()->mutable_header()->set_timestamp( std::chrono::duration_cast< std::chrono::milliseconds >( duration ).count() );
   block_req.mutable_block()->mutable_header()->set_height( 1 );
   block_req.mutable_block()->mutable_header()->set_previous( util::converter::as< std::string >( koinos::crypto::multihash::zero( koinos::crypto::multicodec::sha2_256 ) ) );
   block_req.mutable_block()->mutable_header()->set_previous_state_merkle_root( _controller.get_head_info().head_state_merkle_root() );
   *block_req.mutable_block()->add_transactions() = trx1;
   *block_req.mutable_block()->add_transactions() = trx2;

   set_block_merkle_roots( *block_req.mutable_block(), koinos::crypto::multicodec::sha2_256 );
   block_req.mutable_block()->set_id( util::converter::as< std::string >( koinos::crypto::hash( koinos::crypto::multicodec::sha2_256, block_req.block().header() ) ) );
   sign_block( *block_req.mutable_block(), _block_signing_private_key );

   auto rld = _controller.get_resource_limits( koinos::rpc::chain::get_resource_limits_request() );

   koinos::rpc::chain::get_account_rc_request rc_req;

   rc_req.set_account( util::converter::as< std::string >( contract_private_key.get_public_key().to_address_bytes() ) );
   uint64_t max_payer1 = _controller.get_account_rc( rc_req ).rc();

   rc_req.set_account( util::converter::as< std::string >( alice_private_key.get_public_key().to_address_bytes() ) );
   uint64_t max_payer2 = _controller.get_account_rc( rc_req ).rc();

   auto block_resp = _controller.submit_block( block_req );

   BOOST_TEST_MESSAGE( "Check the resulting block receipt" );

   LOG(info) << block_resp;

   BOOST_REQUIRE_EQUAL( block_resp.receipt().id(), block_req.block().id() );
   BOOST_REQUIRE_EQUAL( block_resp.receipt().transaction_receipts_size(), 2 );
   BOOST_REQUIRE_EQUAL( block_resp.receipt().events_size(), 0 );
   BOOST_REQUIRE(
      block_resp.receipt().disk_storage_used() >=
      block_resp.receipt().transaction_receipts( 0 ).disk_storage_used() +
      block_resp.receipt().transaction_receipts( 1 ).disk_storage_used() );

   BOOST_REQUIRE(
      block_resp.receipt().network_bandwidth_used() >=
      block_resp.receipt().transaction_receipts( 0 ).network_bandwidth_used() +
      block_resp.receipt().transaction_receipts( 1 ).network_bandwidth_used() );

   BOOST_REQUIRE(
      block_resp.receipt().compute_bandwidth_used() >=
      block_resp.receipt().transaction_receipts( 0 ).compute_bandwidth_used() +
      block_resp.receipt().transaction_receipts( 1 ).compute_bandwidth_used() );

   uint64_t rc1 = 0;
   rc1 += block_resp.receipt().transaction_receipts( 0 ).disk_storage_used() * rld.resource_limit_data().disk_storage_cost();
   rc1 += block_resp.receipt().transaction_receipts( 0 ).compute_bandwidth_used() * rld.resource_limit_data().compute_bandwidth_cost();
   rc1 += block_resp.receipt().transaction_receipts( 0 ).network_bandwidth_used() * rld.resource_limit_data().network_bandwidth_cost();

   BOOST_REQUIRE_EQUAL( block_resp.receipt().transaction_receipts( 0 ).id(), trx1.id() );
   BOOST_REQUIRE_EQUAL( block_resp.receipt().transaction_receipts( 0 ).rc_limit(), rc_limit1 );
   BOOST_REQUIRE_EQUAL( block_resp.receipt().transaction_receipts( 0 ).rc_used(), rc1 );
   BOOST_REQUIRE_EQUAL( block_resp.receipt().transaction_receipts( 0 ).payer(), util::converter::as< std::string >( contract_private_key.get_public_key().to_address_bytes() ) );
   BOOST_REQUIRE_EQUAL( block_resp.receipt().transaction_receipts( 0 ).max_payer_rc(), max_payer1 );
   BOOST_REQUIRE_EQUAL( block_resp.receipt().transaction_receipts( 0 ).reverted(), false );
   BOOST_REQUIRE_EQUAL( block_resp.receipt().transaction_receipts( 0 ).events_size(), 0 );

   uint64_t rc2 = 0;
   rc2 += block_resp.receipt().transaction_receipts( 1 ).disk_storage_used() * rld.resource_limit_data().disk_storage_cost();
   rc2 += block_resp.receipt().transaction_receipts( 1 ).compute_bandwidth_used() * rld.resource_limit_data().compute_bandwidth_cost();
   rc2 += block_resp.receipt().transaction_receipts( 1 ).network_bandwidth_used() * rld.resource_limit_data().network_bandwidth_cost();

   BOOST_REQUIRE_EQUAL( block_resp.receipt().transaction_receipts( 1 ).id(), trx2.id() );
   BOOST_REQUIRE_EQUAL( block_resp.receipt().transaction_receipts( 1 ).rc_limit(), rc_limit2 );
   BOOST_REQUIRE_EQUAL( block_resp.receipt().transaction_receipts( 1 ).rc_used(), rc2 );
   BOOST_REQUIRE_EQUAL( block_resp.receipt().transaction_receipts( 1 ).payer(), util::converter::as< std::string >( alice_private_key.get_public_key().to_address_bytes() ) );
   BOOST_REQUIRE_EQUAL( block_resp.receipt().transaction_receipts( 1 ).max_payer_rc(), max_payer2 );
   BOOST_REQUIRE_EQUAL( block_resp.receipt().transaction_receipts( 1 ).reverted(), false );
   BOOST_REQUIRE_EQUAL( block_resp.receipt().transaction_receipts( 1 ).events_size(), 0 );

   LOG(info) << block_resp;

   auto rc_limit3 = 8'000'000;

   koinos::protocol::transaction trx3;
   nonce_value.set_uint64_value( 2 );

   koinos::contracts::token::transfer_arguments xfer_arg;
   xfer_arg.set_from( alice_address );
   xfer_arg.set_to( contract_private_key.get_public_key().to_address_bytes() );
   xfer_arg.set_value( 100 );

   auto op3 = trx3.add_operations()->mutable_call_contract();
   op3->set_contract_id( op1->contract_id() );
   op3->set_entry_point( 0x62efa292 );
   op3->set_args( xfer_arg.SerializeAsString() );
   trx3.mutable_header()->set_rc_limit( rc_limit3 );
   trx3.mutable_header()->set_nonce( util::converter::as< std::string>( nonce_value ) );
   trx3.mutable_header()->set_chain_id( _controller.get_chain_id().chain_id() );
   set_transaction_merkle_roots( trx3, koinos::crypto::multicodec::sha2_256 );
   sign_transaction( trx3, alice_private_key );

   LOG(info) << util::to_base58( alice_private_key.get_public_key().to_address_bytes() );

   koinos::rpc::chain::submit_transaction_request tx_req;
   *tx_req.mutable_transaction() = trx3;

   rld = _controller.get_resource_limits( koinos::rpc::chain::get_resource_limits_request() );

   rc_req.set_account( util::converter::as< std::string >( alice_private_key.get_public_key().to_address_bytes() ) );

   uint64_t max_payer3 = _controller.get_account_rc( rc_req ).rc();

   auto tx_resp = _controller.submit_transaction( tx_req );

   uint64_t rc3 = 0;
   rc3 += tx_resp.receipt().disk_storage_used() * rld.resource_limit_data().disk_storage_cost();
   rc3 += tx_resp.receipt().compute_bandwidth_used() * rld.resource_limit_data().compute_bandwidth_cost();
   rc3 += tx_resp.receipt().network_bandwidth_used() * rld.resource_limit_data().network_bandwidth_cost();

   BOOST_TEST_MESSAGE( "Check the resulting transaction receipt" );

   BOOST_REQUIRE_EQUAL( tx_resp.receipt().id(), trx3.id() );
   BOOST_REQUIRE_EQUAL( tx_resp.receipt().rc_limit(), rc_limit3 );
   BOOST_REQUIRE_EQUAL( tx_resp.receipt().rc_used(), rc3 );
   BOOST_REQUIRE_EQUAL( tx_resp.receipt().payer(), util::converter::as< std::string >( alice_private_key.get_public_key().to_address_bytes() ) );
   BOOST_REQUIRE_EQUAL( tx_resp.receipt().max_payer_rc(), max_payer3 );
   BOOST_REQUIRE_EQUAL( tx_resp.receipt().reverted(), false );
   BOOST_REQUIRE_EQUAL( tx_resp.receipt().events_size(), 0 );

   LOG(info) << tx_resp.receipt();

} KOINOS_CATCH_LOG_AND_RETHROW(info) }

BOOST_AUTO_TEST_SUITE_END()
